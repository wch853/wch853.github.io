---
sidebarDepth: 2
date: 2018-12-30
desc: Java内存区域介绍、垃圾收集器与内存分配策略。
tags: JVM Java内存区域 垃圾回收 内存分配
---
# 深入理解Java虚拟机（二）：虚拟机执行子系统
### 逃逸分析与栈上分配
#### 逃逸分析
通过动态分析对象的作用域，为其它优化手段如同步消除、标量替换和栈上分配等提供依据。逃逸行为有两种：
- 方法逃逸：当一个对象在方法中定义后，作为参数传递到其它方法中。
- 线程逃逸：如类变量或实例变量，可能被其它线程访问到。
#### 同步消除
如果一个对象的作用域在一个线程内，无法被其它线程访问到，那么该对象的读写就不存在竞争，则该对象的同步锁可以被消除。
#### 标量替换
- 标量是指不可分割的量，如Java中的基本数据类型和reference类型，相对一个数据可以继续分解，称为聚合量。
- 把一个对象拆散，其成员变量恢复到基本类型来访问就叫做标量替换。
- 如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量。
##### 栈上分配
栈上分配即在栈上分配对象，目前HotSpot并没有实现真正意义上的栈上分配，实际上是标量替换。当对象的作用域局限在一定边界中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会真正生成对象，大大减轻了GC的压力。

## 类加载
类加载是指虚拟机把描述类的数据从class文件加载（懒加载）到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
### 类加载
![类加载生命周期](/img/jvm/类加载生命周期.png)
Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。

虚拟机规范指定在以下五种情况必须立即对类进行初始化：
- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行初始化，则需要对其初始化，包括：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、在编译期已被放入常量池的静态字段除外）时、调用一个类的静态方法时。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的类），虚拟机会先初始化这个主类。
- 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

### 加载
- 通过一个类的全限定名来获取定义此类的二进制字节流（文件、网络、动态生成）。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

### 验证
验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段不是必须的，它对程序运行期没有影响。验证阶段包含4个主要动作：
- 文件格式验证：验证字节流是否符合Class文件格式的规范：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

### 准备
准备阶段是正式为类变量分配内存并设置初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。如果类变量标注为final变量，准备阶段不会初始化零值，二会初始化为指定的值。

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

### 初始化
初始化阶段是执行类构造器 `<clinit>()` 方法的过程。`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，在前面的静态语句块可以赋值，但是不能访问。在同一个类加载器下，一个类型只会被初始化一次。

### 类加载器
类加载器的作用是将class文件加载到内存中，并为其生成java.lang.Class对象加载到Java虚拟机中。在JVM中，一个类用其全限定名和其类加载器作为其唯一标识。
#### 类加载器划分
- 启动类加载器（BootStrap ClassLoader）：是虚拟机的一部分，用于加载Java核心库目录下的类。
- 扩展类加载器（Extension ClassLoader）：用于加载Java扩展库目录下的类。
- 应用程序类加载器（Application ClassLoader）：一般用户类路径（ClassPath）目录下的类都是由这个类加载器加载的，是系统默认类加载器。
##### 双亲委派模式
![双亲委派模式](/img/jvm/双亲委派模式.png)
如果一个类加载器收到了一个类加载请求，它不会自己去尝试加载这个类，而是把这个请求转交给父类加载器去完成。每一个层次的类加载器都是如此。因此所有的类加载请求都应该传递到最顶层的启动类加载器中，只有到父类加载器反馈自己无法完成这个加载请求（在它的搜索范围没有找到这个类）时，子类加载器才会尝试自己去加载。同一个限定名的类被不同类加载器加载会生成不同类，将类加载请求逐层转交，避免了有些类被重复加载。越是基础的类，越是被上层的类加载器加载，保证了Java程序的稳定。
