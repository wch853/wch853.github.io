## 平均负载

 平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数，也就是**平均活跃进程数**。

### uptime 命令

```bash
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```

使用 `uptime` 命令可以查看过去1分钟、5分钟、15分钟的平均负载（`Load Average`）。

### 查看 CPU 个数

```bash
grep 'model name' /proc/cpuinfo | wc -l
```

如果平均负载大于 `CPU` 个数，那么说明系统已经过载。

### 平均负载与 CPU 使用率

平均负载统计的不仅是正在使用 `CPU` 的进程，还包括等待 `CPU` 和等待 `I/O` 的进程，对于 `CPU` 密集型进程来说两者是一致的；对于 `I/O` 密集型进程则不一定。

### CPU 使用率情况

通过 `mpstat` 命令查看  ` %usr ` 和 ` %iowait ` 列的 `CPU` 使用率判断当前系统负载高是由 `CPU` 运算还是 `iowait` 引起的。

```bash
# 监控所有 CPU，间隔5秒输出一组数据
mpstat -P ALL 5
```

通过 `pidstat` 命令查看导致 `CPU` 使用率升高的进程。`%wait` 显示进程等待 `CPU` 的时间。

```bash
# 间隔5秒后输出一组数据，-u表示CPU指标
pidstat -u 5 1
```

## CPU 上下文

`CPU` 上下文指任务运行前依赖的寄存器和程序计数器。寄存器是 `CPU` 内置的容量小、速度快的内存；程序计数器则是用来存储 `CPU` 正在执行的指令位置，或者即将执行的下一条指令位置。

### CPU 上下文切换

`CPU` 上下文切换指的是将上一个任务的 `CPU` 上下文保存起来，然后加载新任务的上下文。

过多的上下文切换，会把 `CPU` 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。 

根据任务的不同，`CPU` 的上下文切换就可以分为几个不同的场景，也就是**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。 

#### 进程上下文切换

进程上下文切换会涉及寄存器、内核栈以及虚拟内存等数据的保存和恢复。

- 为了保证所有进程可以得到公平调度，CPU时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。 
- 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。 
- 当进程通过睡眠函数 `sleep` 这样的方法将自己主动挂起时，自然也会重新调度。
- 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。 
- 发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序。 

#### 线程上下文切换

- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的。
- 前后两个线程属于不同进程时，因为资源不共享，所以切换过程跟进程上下文切换是一样。 
- 前后两个线程属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。 

#### 中断上下文切换

为了快速响应硬件事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。对于同一个 `CPU` 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。

### 查看 CPU 上下文切换情况

```bash
# 查看CPU上下文切换情况，间隔1秒输出1组数据
vmstat 1
```

`cs(context switch)` 列显示每秒上下文切换次数、`in(interupt)` 列显示每秒中断次数、`r(Running or Runnable)` 是就绪队列的长度，即正在运行和等待 `CPU` 的进程数、`b(blocked)` 则是处于不可中断睡眠状态的进程数。

```bash
# 查看进程上下文切换情况，间隔5秒输出1组数据
pidstat -w 5
```

`cswch` 列表示自愿上下文切换，即进程无法获取所需资源（`I/O`、内存等），导致的上下文切换。

`nvcswch` 列表示非资源上下文切换，即时间片已到等原因被系统强制调度，进而发生上下文切换。

## 定位 CPU 使用率过高

使用 `top` 命令查看当前各进程 `CPU`、内存等使用情况：

```bash
top - 04:15:22 up 13:51,  2 users,  load average: 0.01, 0.04, 0.05
Tasks: 124 total,   1 running, 123 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.2 us,  0.3 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  7990124 total,  3514012 free,  3146764 used,  1329348 buff/cache
KiB Swap:  5242876 total,  5242876 free,        0 used.  4554532 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 11920 1000      20   0 4734688 997.3m  16744 S   0.7 12.8   4:28.48 java
```

功能键：

- `1`：切换查看每个 `CPU` 的指标。
- `M`：按内存使用大小排序。
- `P`：按 `CPU` 使用率排序。
- `H`：查询线程指标。

定位到 `CPU` 使用率高的线程后通过 `top -Hp pid` 查看指定进程下的所有线程指标，找到使用率最高的线程，获取线程 `tid`。退出 `top`，使用 `printf %x\n%  tid` 获取十六进制线程号并查看此线程的执行栈：

```bash
jstack pid | grep hex -A 20
```

