---
sidebarDepth: 2
date: 2018-12-31
desc: Java内存区域介绍、垃圾收集器与内存分配策略。
tags: JVM Java内存区域 垃圾回收 内存分配
---

# 深入理解 Java 虚拟机（二）：虚拟机执行子系统

## 类加载

虚拟机把描述类的数据从 `class` 文件（一串二级制字节流）加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 `Java` 类型，这就是虚拟机的类加载机制。

### 类加载时机

类从加载到内存开始，到卸载出内存为止，其生命周期包括加载、连接、初始化、使用、卸载，其中连接阶段又可分为验证、准备和解析。

![类的生命周期](D:\Java\code\VisualStudioCodeProjects\wch853.github.io\docs\.vuepress\public\img\jvm\类的生命周期.png)

虚拟机规范并没有强行约束什么情况下需要开始类加载，但是严格规定了只有以下情况需要立即对类进行初始化：

- 使用 `new` 关键字创建对象、读取或设置一个类的静态字段（常量除外）或调用一个类的静态方法。
- 对类进行反射调用或对类的静态方法进行反射调用。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()` 方法的类），虚拟机会先初始化这个主类。
- 初始化类时，如果父类未进行过初始化，需要先触发其父类的初始化。

#### 加载

- 通过一个类的全限定名来定义此类的二进制字节流。
- 将字节流代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的 `Class` 对象，作为方法区这个类的各种数据的访问入口。

虚拟机规范并没有限定二进制字节流从哪里获取，因此不仅能通过 `class` 文件中加载，开发者可以通过自定义类加载器来完成类加载。

#### 验证

验证是连接阶段的第一步，目的是为了确保 `Class` 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。如果所运行的全部代码都已经反复使用和验证过，那么在实施阶段就可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

##### 文件格式验证

文件格式验证的目的是为了保证输入的字节流能够正确解析并存储与方法区中。

- 是否以魔数 `0xCAFEBABE` 开头。
- 主、次版本号是否在当前虚拟机处理范围内。
- 常量池中的常量是否有不支持的类型。

……

##### 元数据验证

元数据验证旨在对字节码描述的信息进行语义分析，以保证其描述的信息符合 `Java` 语言规范的要求。

- 这个类是否有父类。
- 这个类的父类是否继承了不允许被继承的类。
- 如果类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾。

……

##### 字节码验证

字节码验证阶段将对对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机的行为。

- 保证跳转指令不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换是有效的。

……

由于字节码验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，给方法体 `Code` 属性的属性表中增加了一项名为 `StackMapTable` 的属性，该属性描述了方法体中的所有基本块（按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证阶段只需要检查该属性中的记录是否合法即可。这样将字节码验证的类型推导转为类型检查，从而节省了一定的时间。

##### 符号引用验证

符号引用验证发生在类解析阶段，是对类自身以外的信息进行匹配性校验，用来确保解析动作能正确执行。

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的访问性是否可被当前类访问。

……

#### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的过程，这些变量使用的内存都将在方法区中进行分配。

![数据类型初始值](D:\Java\code\VisualStudioCodeProjects\wch853.github.io\img\jvm\数据类型初始值.png)

如果类字段被 `final` 修饰，在准备阶段字段即被赋值为指定的值。

#### 解析

解析阶段是将符号引用转化为直接引用的过程。

- 符号引用：是以一组用来描述所引用目标的符号。
- 直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。

##### 类或接口的解析

如果当前类需要将一个从未解析过的符号引用解析为一个类或接口的直接引用，需要进行以下步骤：

- 如果目标类不是一个数组类型，那虚拟机会使用当前类的类加载器去加载目标类，在加载过程中，又可能触发其它相关类的加载动作，一旦加载过程出现任何异常，解析过程就宣告失败。
- 如果目标类是一个数组，则会按上述流程加载数组元素类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
- 进行符号引用验证。

##### 字段解析

- 先对字段所属的类或接口的符号引用进行解析。
- 如果目标类实现了接口或继承了其它类，则会从下往上递归搜索简单名称和描述符都匹配的直接引用。

##### 类方法解析

- 先对字段所属的类或接口的符号引用进行解析。
- 如果目标类实现了接口或继承了其它类，则会在父接口或父类中查找是否有简单名称和描述符都匹配的方法。

##### 接口方法解析

- 先对字段所属的类或接口的符号引用进行解析。
- 在接口或父接口中查找是否有简单名称和描述符都匹配的方法。

#### 初始化

初始化阶段是执行类构造器 `<clinit>` 方法的过程，`<clinit>` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。

- 父类的 `<clinit>` 方法会先于子类执行。
- 如果一个类中没有静态语句块也没有对类变量的赋值操作，那么编译器可以不用生成 `<clinit>` 方法。
- 执行接口的 `<clinit>` 方法不需要先执行父接口的 `<clinit>` 方法，直到父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时同样不会执行接口的 `<clinit>` 方法。
- 虚拟机会保证一个类的 `<clinit>` 方法在多线程环境中被正确地加锁、同步。

### 类加载器

加载过程中将类的二进制字节流加载到内存的过程是通过类加载器完成的。除了加载类，类加载器还用来确定被加载的类的唯一性，即任意一个类需要由加载它的keu加载器和类本身一同确立其在虚拟机中的唯一性。

大部分程序都会使用到以下类加载器：

- 启动类加载器（`Bootstrap ClassLoader`）：用于加载 `<JAVA_HOME>\lib` 目录中的文件。
- 扩展类加载器（`Extension ClassLoader`）：用于加载 `<JAVA_HOME>\lib\ext` 目录中的文件。
- 应用程序类加载器（`Application ClassLoader`）：用于加载 `classpath` 下的文件。如果应用程序中没有自定义过自己的类加载器，一般情况下是默认的类加载器。

#### 双亲委派模式

双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器的都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

![双亲委派模型](D:\Java\code\VisualStudioCodeProjects\wch853.github.io\docs\.vuepress\public\img\jvm\双亲委派模型.png)

使用双亲委派模型来组织类加载器之间的关系，使得类和它的类加载器一起具备了一种带有优先级的层次关系，避免系统中会出现多个不同的同名类。

双亲委派模式的实现为加载类对象时调用 `java.lang.ClassLoader` 的 `loadClass()` 方法，先检查类是否已经加载过，若没有加载则调用父加载器的 `loadClass()` 方法；若当前类加载器的父加载器为空则默认使用启动类加载器作为父加载器；如果父加载器加载失败，抛出 `ClassNotFoundException` 异常后再调用当前类加载器的 `findClass()` 方法进行加载。

#### 破坏双亲委派模型

##### 兼容 1.0 版本类加载器

双亲委派模式在 `JDK 1.2` 之后才被引人，在此之前自定义 `ClassLoader` 往往是通过重写其 `loadClass()` 方法，也就无法向父加载器委派加载请求。为了遵循双亲委派模型，自定义类加载器应重写 `findClass()` 方法来实现。

##### 加载 SPI 实现类

`SPI` 代码往往由独立厂商实现并部署在 `classpath` 下，为了能够加载这些类，虚拟机使用了线程上下文类加载器（`Thread Context ClassLoader`）。这个类加载器可以通过 `java.lang.Thread` 类的 `setContextClassLoader` 方法进行设置，如果创建线程还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。使用线程上下文类加载器去加载所需的 `SPI` 代码，实际上已经违背了双亲委派模型的一般性原则，但是基本上 `Java` 中所有涉及 `SPI` 的加载动作基本上都采用了这种方式，如 `JNDI`、`JDBC` 等。

##### 对动态性的追求

动态性指的是代码热替换、模块热部署等，动态性的目的是让代码能够可插拔的特性。

## 虚拟机字节码执行引擎

### 运行时栈帧结构

栈帧（`Stack Frame`）是用于支持虚拟机进行方法调用和方法执行的数据结构，



## 类文件结构

### 平台无关性

由于硬件体系结构和操作系统的不同，为了能够在不同平台上运行，计算机程序需要通过不同的编译器编译成计算机能够执行的二进制代码。`Java` 之所以能号称 `Write Once, Run Anywhere`，是因为各种虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行一种平台无关的字节码，即 `Class` 类文件。字节码文件中包含了 `Java` 虚拟机指令集合符号表以及若干其它辅助信息，并通过许多强制性的语法和结构化约束来确保安全性。

### Class 类文件的结构

`Class` 文件是一组以 `8` 位字节为基础单位的二进制流，各个数据项目按照顺序紧凑地排列在 `Class` 文件中，中间没有任何分隔符。

### 逃逸分析与栈上分配

#### 逃逸分析

通过动态分析对象的作用域，为其它优化手段如同步消除、标量替换和栈上分配等提供依据。逃逸行为有两种：

- 方法逃逸：当一个对象在方法中定义后，作为参数传递到其它方法中。
- 线程逃逸：如类变量或实例变量，可能被其它线程访问到。

#### 同步消除

如果一个对象的作用域在一个线程内，无法被其它线程访问到，那么该对象的读写就不存在竞争，则该对象的同步锁可以被消除。

#### 标量替换

- 标量是指不可分割的量，如 Java 中的基本数据类型和 reference 类型，相对一个数据可以继续分解，称为聚合量。
- 把一个对象拆散，其成员变量恢复到基本类型来访问就叫做标量替换。
- 如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量。

##### 栈上分配

栈上分配即在栈上分配对象，目前 HotSpot 并没有实现真正意义上的栈上分配，实际上是标量替换。当对象的作用域局限在一定边界中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会真正生成对象，大大减轻了 GC 的压力。
