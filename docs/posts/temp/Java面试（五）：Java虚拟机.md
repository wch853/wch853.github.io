# Java面试（五）：Java

## 平台无关性

平台无关性指在计算机上运行不受平台约束。`Java` 号称 `write once, run everywhere`，即一次编译，到处运行。对于不同的硬件和操作系统，最主要的区别就是二进制指令的不同，`Java` 之所以能做到跨平台，就是因为虚拟机能够将 `javac` 编译生成的字节码文件根据硬件和操作系统生成对应的二进制指令，由此实现平台无关性。

### 反射

`Java` 反射机制指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对与任意一个对象，都能够调用它的任意方法和属性。

### ClassLoader

`ClassLoader` 工作在 `class` 装载的加载阶段，其主要作用是从系统外部获得 `class` 的二级制数据流，然后交给 `Java` 虚拟机进行连接、初始化等操作。

- `BootStrapClassLoader`：`C++` 编写，用于加载核心库 `Java.*`
- `ExtClassLoader`：`Java` 编写，用于加载扩展库 `javax.*`
- `AppClassLoader`：`Java` 编写，加载程序所在目录
- 自定义 `ClassLoader`：`Java` 编写，定制化加载

#### 双亲委派机制

在 `class` 加载的过程中，下层的 `ClassLoader` 会委派上层 `ClassLoader` 去查询需要加载的 `class` 是否已经被加载过。如果已经加载，则无需重新加载；如果没有加载，则希望委派上层 `ClassLoader` 进行加载，如果不能加载，会传递给下一层的 `ClassLoader` 进行加载。

通过使用双亲委派机制加载 `class`，可以避免同样的字节码被加载多份。

### 类装载过程

- 加载：通过 `ClassLoader` 将对应的字节码加载到内存中，生成 `Class` 对象
- 验证：字节码验证，校验字节码的正确性和安全性
- 准备：为类变量分配内存并设置类变量的初始值
- 解析：将常量池中的符号引用替换为直接引用
- 初始化：执行类构造器 `<client>` 方法，即对类变量赋值和执行静态语句块

## Java内存模型

### 地址空间划分

- 内核空间：运行操作系统和驱动程序
- 用户空间：运行用户应用程序

### 运行时数据区

#### 程序计算器

当前线程执行的字节码的逻辑行号指示器

#### 虚拟机栈

`Java` 方法执行的内存模型，每个方法执行时都会创建栈帧，用于存储局部变量表、操作栈、动态连接，返回地址，对应每个方法从入栈到出栈的过程。

#### 方法区

方法区用于存储类的信息，在 `JDK1.7` 及之前这部分信息存储在永久代（`PermGen`），`JDK1.8` 后存储在元空间（`MetaSpace`）。

##### 元空间与永久代的区别

元空间使用本地内存，永久代使用的是虚拟机的内存，元空间相对于方法区存在若干优势：

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出。
- 类和方法的信息大小难以确定，给指定永久代的大小带来困难。
- 永久代会为 `GC` 带来不必要的复杂性
- 永久代是 `HotSpot` 所特有的，使用元空间替代方便与其它虚拟机集成

### 堆

堆（`Heap`）是对象实例的分配区域，

### Java性能调优参数

- `-Xss`：规定了每个虚拟机栈（堆栈）的大小，会影响进程中所能创建的并发线程数的大小
- `-Xms`：堆的初始大小
- `-Xmx`：堆可以扩展到的最大容量

### 堆和栈的区别

- 对象和数组在堆中分配内存空间，栈中定义变量保存堆中目标数据的首地址
- 栈内存在栈销毁时就可以释放，堆中内存的回收依赖 `GC`
- 堆内存一般远大于栈内存
- 栈产生的碎片远小于堆
- 栈支持静态分配（在编译期即可确定占用的内存空间）和动态分配，堆仅支持动态分配
- 栈的效率比堆高（栈的操作只有入栈和出栈，更为简单）

### intern() 方法

#### JDK6

常量池在方法区中，调用 `intern` 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该对象的引用，否则将此字符串对象添加到字符串常量池中，并返回池中该对象的引用。方法区大小是有限的，频繁调用 `intern` 方法可能会导致内存溢出。

#### JDK6+

常量池在堆中，调用 `intern` 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该对象的引用。否则如果该字符串对象已经存在于 `Java` 堆中，则将堆中此对象的引用添加到字符串常量池中并返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。