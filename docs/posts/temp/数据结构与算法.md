# 数据结构与算法

## Collection

### List

#### ArrayList

- 使用对象数组 `Object[] elementData` 来存储元素。

- 默认容量为 `10`，但是 `new ArrayList<>()` 会使 `elementData` 指向一个空数组，当加入元素时才对数组进行扩容。
- 使用 `size` 变量维护元素数量，`size()` 方法对外返回元素数量。
- 使用 `modCount` 维护列表修改次数。
- 数组扩容 / 缩容通过 `native` 方法 `System.arraycopy` 实现。
- `trimToSize` 方法：元素数组缩容到元素数量大小，最小化内存占用。
- 元素数组扩容：

```java
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
      	// 新容量 = 老容量 * 1.5
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
          	// 保证最小容量
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
          	// 大容量处理
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }

    private void ensureExplicitCapacity(int minCapacity) {
      	// 维护列表修改次数
        modCount++;
      
        if (minCapacity - elementData.length > 0)
        		// 要求最小容量超出元素数组长度，进行扩容
            grow(minCapacity);
    }
```

- `indexOf` 方法用于查找指定元素的索引，如果元素存在仅返回其在列表中的第一个索引。`lastIndexOf` 方法用于在元素存在时返回其在列表的最后一个索引。

```java
    public int indexOf(Object o) {
      	// 逐个遍历查找索引
        if (o == null) {
            for (int i = 0; i < size; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = 0; i < size; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
      	// 查找不到返回 -1
        return -1;
    }
```

- `clone` 方法返回当前列表的一个浅拷贝对象。
- `toArray` 无参方法返回列表元素数组对象的一个拷贝，数组中元素的引用不变。
- `T[] toArray(T[] a)` 方法。

```java
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // 传入数组长度小于当前元素数组长度，返回当前数组对象的拷贝
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
      	// 否则将元素数组内容拷贝到传入数组中
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
          	// 超出部分元素设为 null
            a[size] = null;
        return a;
    }
```

- `get`、`set` 方法直接对元素数组进行操作。
- `add` 方法会默认将新增元素添加到元素末尾；指定添加元素的 `add` 方法会涉及对数组的拷贝：

```java
    public void add(int index, E element) {
      	// 索引范围检测
        rangeCheckForAdd(index);
				
      	// 保证数组大小足够放入新增元素
        ensureCapacityInternal(size + 1);  // Increments modCount!!
      	// 指定索引位置向后的元素往后移动一位
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
      	// 新增元素
        elementData[index] = element;
      	// 维护新数量
        size++;
    }
```

- `remove` 方法分为指定索引删除和指定元素删除，如果被删除元素不是最后一位元素，会涉及数组拷贝。
- `clear` 方法会将所有数组元素设置为 `null`。
- `addAll` 方法会对原数组扩容，并将新增元素加到数组末尾：

```java
    public boolean addAll(Collection<? extends E> c) {
        Object[] a = c.toArray();
        int numNew = a.length;
      	// 原数组扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
      	// 将新增元素添加到数组末尾
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    }
```

- `removeAll(Collection<?> c)` 方法表示移除当前列表中包含的集合 `c` 中的元素，`retainAll(Collection<?> c)` 方法表示保留当前列表与集合 `c` 的交集元素，他们都是依赖 `batchRemove` 方法实现的：

```java
    private boolean batchRemove(Collection<?> c, boolean complement) {
        final Object[] elementData = this.elementData;
      	// r 为前进指针，w 为有效元素指针
        int r = 0, w = 0;
        boolean modified = false;
        try {
            for (; r < size; r++)
              	// removeAll 调用传入 complete=false，即保留不包含的元素
              	// retainAll 调用传入 complete=true，即保留包含的元素
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
              	// contains 方法调用可能产生异常，将后面的元素全部复制
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            }
            if (w != size) {
                // clear to let GC do its work
                for (int i = w; i < size; i++)
                  	// 有效元素指针后的元素全部设置为 null，让 GC 能够工作
                    elementData[i] = null;
                modCount += size - w;
                size = w;
                modified = true;
            }
        }
        return modified;
    }
```

- `iterator` 方法用于返回当前列表的可迭代对象。

```java
    private class Itr implements Iterator<E> {
      	// 当前指向的索引
        int cursor;       // index of next element to return
      	// 当前索引的上一个索引
        int lastRet = -1; // index of last element returned; -1 if no such
      	// 记录可迭代对象创建时的列表修改次数
        int expectedModCount = modCount;

        Itr() {}

        public boolean hasNext() {
          	// 索引不溢出
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
          	// 检查修改
            checkForComodification();
          	// 获取当前指针
            int i = cursor;
            if (i >= size)
              	// 溢出抛异常
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
          	// 游标进位
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
          	// 检查修改
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
              	// 删除导致后面的元素前移
                cursor = lastRet;
                lastRet = -1;
              	// 维护修改次数
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

      	// 从 cursor 位置开始向后遍历
        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
              	// 如果列表在迭代对象使用过程中被修改，抛出异常
                throw new ConcurrentModificationException();
        }
    }
```

- `listIterator` 方法返回一个增强的可迭代对象。其继承了 `Itr` 并进行了拓展。

```java
    private class ListItr extends Itr implements ListIterator<E> {
        ListItr(int index) {
            super();
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor - 1;
        }

      	// 游标前移
        @SuppressWarnings("unchecked")
        public E previous() {
            checkForComodification();
            int i = cursor - 1;
            if (i < 0)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i;
            return (E) elementData[lastRet = i];
        }
				
      	// 更新当前索引位置元素
        public void set(E e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.set(lastRet, e);
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

      	// 在当前索引位置插入元素
        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                ArrayList.this.add(i, e);
                cursor = i + 1;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }
```

#### LinkedList

- `Node` 描述了 `LinkedList` 的节点结构，其包含了存储的实际元素和分别指向前驱和后继的指针。

```java
    private static class Node<E> {
      	// 存储元素
        E item;
      	// 前驱指针
        Node<E> next;
      	// 后继指针
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

- `first`、`last` 属性分别用于指向当前列表的头结点和尾节点。





#### RandomAccess

`RandomAccess` 接口用于标记支持随机访问的 `List`，其文档表明如果一个 `List` 的 `for` 循环快于迭代器，那么就应该实现 `RandomAccess` 接口。



