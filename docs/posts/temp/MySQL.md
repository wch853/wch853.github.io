# MySQL

## MySQL 逻辑架构

![MySQL逻辑架构](D:\doc\typora\image\MySQL逻辑架构.png)



- 最上层服务包括连接处理、授权认证安全等等。每个客户端连接都会在服务器进程中拥有一个线程，每个连接的查询只会在单独的线程中执行，服务器线程轮流在某个 `CPU核心` 或 `CPU` 中运行。当客户端连接到 `MySQL` 服务器时，服务器会基于用户名、原始主机信息和密码对其进行认证，并对该客户端是否能够执行某个特定查询进行鉴权。
- 第二层包含 `MySQL` 跨存储引擎的功能，包括存储过程、触发器、视图，以及查询解析、分析、优化、缓存和所有的内置函数（日期、时间、数学和加密函数）。在这一层 `MySQL` 还会解析查询，进行各种优化，包括重写查询、决定表的读取顺序、以及选择合适的索引等。
- 第三层包含了存储引擎，负责 `MySQL` 中的数据存储和提取。

## 并发控制

### 读写锁

在处理并发读或并发写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种锁分别为 `共享锁（读锁）` 和 `排他锁（写锁）`。读锁之间不会相互阻塞，而写锁会阻塞其他的读锁和写锁。

### 锁粒度

在给定的资源上，锁定的数据量越少，则系统的并发程度更高。加锁也需要消耗资源，锁的各种操作，包括获取锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡。

#### 表锁

表锁会锁定整张表。写操作需要首先获取写锁，这会阻塞其他用户对该表的所有读写操作。没有写锁时，其他操作才能获取读锁，读锁之间不会相互阻塞。

#### 行级锁

行级锁可以最大程度地支持并发处理，同事也带来了最大的锁开销。

## 事务

事务是一组原子性的 `SQL` 查询，或者说一个独立的工作单元。在事务执行过程中有任何一条语句因为崩溃或其它原因无法执行，那么其它语句也不会执行。即要么全部执行成功，要么全部执行失败。

### ACID

- `atomicity`：原子性。对于一个事务来说，所有操作要么全部执行，要么全部不执行（回滚），不可能执行其中一部分。
- `consistency`：一致性。数据库总是从一个一致性的状态转换到另一个一致性的状态。
- `isolation`：隔离性。一个事务所做的修改在最终提交前，对其他事务通常来说是不可见的。
- `durability`：持久性。一旦事务提交，则其所做的修改就会永久保存到数据库中。

### 隔离级别

`SQL` 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- `READ UNCOMMITTED`：未提交读。事务中的修改，即使没有提交，对其他事务也都是可见的。此种隔离级别会产生 `脏读`，即事务可以读取其它事务未提交的数据。
- `READ COMMITTED`：提交读。一个事务从开始执行直到提交之前，其所做的修改对其他事务是不可见的。此种事务隔离级别会产生 `不可重复读`，即执行两次相同的查询，可能会得到不一样的结果。
- `REPEATABLE READ`：可重复读。该级别保证了在同一个事务中多次读取同样的记录的结果是一致的，但是无法解决 `幻读` 的问题，即当前事务在读取某个范围内的记录时，其它事务又在该范围内插入了新的记录，当前事务再次读取该范围内的记录时，会产生幻行。
- `SERIALIZABLE`：可串行化。强制事务串行执行，在读取的每一行数据上都加锁。

### 死锁

两个或多个事务互相请求锁定对方占用的资源，但是又不肯释放已经占用的资源，就会产生死锁。

#### 处理死锁的方式

- 检测到死锁的循环依赖，立即返回一个错误。
- 查询时间达到锁等待超时的设定后放弃锁请求。
- 将持有最少行级排它锁的事务进行回滚。

### 事务日志

事务日志可以帮助提高事务的效率。使用事务日志，存储引擎修改表的数据时只需要修改其内存拷贝，再把该修改行为记录持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是在磁盘上的一小块区域内顺序 `I/O`，而不像随机 `I/O` 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。

事务日志持久之后，内存中修改的数据会在后台慢慢地刷回磁盘。如果数据修改已经持久化到事务日志，但数据还没有写入磁盘，此时系统崩溃，存储引擎可以在重启时自动恢复这部分修改的数据。

#### MySQL事务

#### 自动提交

`MySQL` 默认自动提交，如果不显式地开始一个事务，则每个查询都被当做一个事务提交操作。可以通过设置 `AUTOCOMMIT` 变量来启用或禁用自动提交。

```mysql
# 查询自动提交模式
SHOW VARIABLES LIKE 'AUTOCOMMIT';
# 设置自动提交
SET AUTOCOMMIT = 1;
```

当 `AUTOCOMMIT` 为0时，所有的查询都在同一个事务中，直到显式地执行 `COMMIT` 或者 `ROLLBACK` 才会结束当前事务，同时开启一个新的事务。

## 多版本并发控制

多版本并发控制`MVCC` (`Multi-Version Concurrency Control`)，是通过保存数据在某个时间点的快照来实现的，无论事务执行多长时间，在每个事务内看到的数据都是一致的，不同事务在同一时刻看到的数据可能是不一样的。`MVCC` 在很多情况下避免了加锁操作，因此开销更低。

#### InnoDB 对 MVCC 的实现

`InnoDB`  维护了一个系统版本号，每开始一个新的事务，系统版本号就会递增，事务开始时系统版本号会作为事务的版本号。`InnoDB` 的 `MVCC` 是通过在每行记录后面保存两个隐藏的列来实现的，两个列分别保存了行创建的事务版本号和行删除的事务版本号。

在 `REPEATABLE READ` 隔离级别下，`MVCC` 的具体操作如下：

- `SELECT`：行创建事务版本号小于或等于当前事务版本号（确保行在当前事务或当前事务开启前创建）；行删除事务版本号未定义或大于当前事务版本号（确保行在当前事务结束之前未被删除）。只有符合这两个条件的记录才能返回作为查询结果。
- `INSERT`：为插入的每一行保存当前事务版本号作为行创建版本号。
- `DELETE`：为删除的每一行保存当前事务版本号作为行删除版本号。
- `UPDATE`：插入新的一行，保存当前事务版本号作为行创建版本号，同时保存当前事务版本号到原来的行作为行删除版本号。

通过维护行创建和删除的版本号，可以使得大多数读操作都无需加锁，不足之处是每行都需要额外的存储空间，需要更多的行检查和维护工作。

## 存储引擎

### InnoDB

`InnoDB` 是 `MySQL` 的默认事务引擎，它被设计用来处理大量的短期事务（大部分情况是正常提交的，很少会被回滚）。`InnoDB` 使用 `MVCC` 来支持高并发，并且实现了四个标准的隔离级别，其默认级别为 `REPEATABLE READ`，并且通过间隙锁（`next-key locking`）策略防止幻读，间隙锁通过对索引的间隙进行锁定来防止幻行的插入。

### MyISAM

`MyISAM` 不支持事务和行级锁，在崩溃后无法安全恢复，读取时会对读到的所有表加共享锁，写入时则对表加排它锁。

## 数据类型

### 整数类型

存储整数可以使用 `TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`，它们分别使用 8、16、24、32、64 位存储空间。它们可以存储的值为 `-2^(N-1)` ~ `2^(N-1)`（N为存储空间位数）。

### 实数类型

对于带小数部分的数字，可以使用 `DECIMAL` 进行高精度计算，这是 `MySQL` 自身实现的，相对而言，`CPU` 直接支持原生浮点计算，浮点类型在存储相同范围的值时，通常比 `DECIMAL` 使用更少的空间。

### 字符串类型

- `VARCHAR`：用于存储可变长字符串，比定长更节省空间，因为它仅适用必要的空间。需要额外的 1 ~ 2 字节来存储字符串的长度。
- `CHAR`：用于存储短且长度接近的字符串，不需要额外的空间存储字符串长度。

### 枚举类型

如果某一列的数据为不重复的字符串，则可以使用枚举类型代替字符串类型。枚举类型在记录中实际保存的是整数，因此会被压缩到一到两个字节。`MySQL` 会单独维护一个查找表用于维护数字-字符串的映射关系。

### 日期和时间类型

- `DATETIME`：占用 8 个字节，与时区无关，默认情况下以一种可排序的、无歧义的格式显示：`YYYY-MM-dd HH:mm:ss`。
- `TIMESTAMP`：占用 4 个字节，依赖于时区，只能表示从 1970 年到 2038 年。

## 索引

索引是存储引擎用于快速找到记录的一种数据结构。索引的存在大大减少了服务器需要扫描的数据量，可以帮助服务器避免排序和建立临时表，可以将随机 `I/O` 变为顺序 `I/O`。

### 索引分类

#### B-Tree 索引

![MySQL逻辑架构](D:\doc\typora\image\B+TREE索引.jpg)

`InnoDB` 存储引擎使用 `B+Tree` 实现其索引结构，树中的每个叶子节点对应 `InnoDB` 存储引擎的逻辑磁盘页（申请磁盘空间时通过连续磁盘块来表示页，读入数据到内存中也会以页为单位）。`B+Tree` 的非叶子节点只存储键值信息，因此可以存储更多的键和指针，降低了树的高度，减少了对磁盘的 `I/O` 次数。所有非叶子节点都有链指针指向其他的叶子节点，可用于范围查找和分页查找。数据都存放在叶子节点中，如果是聚集索引，叶子节点会存放行记录数据，如果是非聚集索引，叶子节点会存放行数据对应的聚集索引（主键）；当使用非聚集索引查询数据时，会通过二次查询来定位具体的行数据（数据移动就不需要维护聚簇索引），但是如果查询的列都在该索引中，则可以直接完成查询。

#### 哈希索引

哈希索引是对所有的索引列计算一个哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。只有精确匹配索引的所有列才有效。由于哈希索引只需存储对应的哈希值，所以结构十分紧凑，这也让哈希索引查询速度非常快。

### 高性能索引策略

#### 独立的列

索引列不能作为表达式的一部分活函数中的参数出现在查询条件中。

#### 建立选择性高的索引

不重复的索引值（`cardinality`） 与数据记录总数的比值越高，就能在查找中过滤更多的行。

#### 使用前缀索引

如果需要索引较长的字符列，可以通过索引开始部分的字符来提高选择性，同时降低索引全部字符带来的开销。

#### 避免索引合并

在部分情况下查询能够对多个单列索引扫描，合并结果。但是索引合并会消耗大量服务器资源，如果索引选择性不高，还会返回大量数据，应尽量避免。

#### 选择合适的索引列顺序

将选择性高的列放到索引前列，可以更快地过滤出需要的行。

#### 聚簇索引

当表有聚簇索引时，它的数据行实际存放在索引的叶子页，非叶子节点仅包含索引列。聚簇表示数据行和相邻的键值紧凑地存储在一起，因此可以更快地通过聚簇索引找到数据。

![InnoDB聚簇索引](D:\doc\typora\image\Inno聚簇索引.png)

`InnoDB` 聚簇索引的每个叶子节点都包含了主键值、`事务ID`、用于事务和 `MVCC` 的回滚指针以及所有的剩余列。如果主键是一个前缀索引，叶子节点也会包含完整的主键列和剩下的其它列。主键最好使用自增列，这样可以保证数据是按顺序写入的；应该避免随机聚簇索引，以免使得数据失去聚集特性，并造成大量随机 `I/O` 和页分裂。

#### 二级索引

![InnoDB二级索引](D:\doc\typora\image\InnoDB二级索引.jpg)

`InnoDB` 的二级索引（非聚簇索引）与聚簇索引不同，其叶子节点中存储的是主键值，当使用二级索引定位数据时先找到对应行的主键值再通过聚簇索引定位剩下的数据列。由于二级索引指向的是主键值，而不是行记录，因此数据移动时无需对二级索引重新维护。

#### 覆盖索引

如果一个索引包含了所有需要查询的字段的值，则称之为覆盖索引。对于 `InnoDB` 来说，覆盖索引包含了索要查询的所有字段的值，避免了对主键索引的二次查询。当发起一个被索引覆盖的查询，`Explain` 的 `Extra` 列可以看到 `Using index` 信息。对于某些查询，可以先在子查询中使用覆盖索引过滤出必要的行的某些字段，再通过子查询获取的字段进行延迟关联。这种方式可以减少 `MySQL` 扫描需要丢弃的行数来提高性能。

#### 使用索引扫描来做排序

当 `ORDER BY` 子句的顺序和索引列的顺序完全一致，并且子句中的列排序方向一致（都是正序或倒序），就可以使用索引来对结果做排序，其中 `ORDER BY` 子句也需要满足最左前缀原则，如果 `WHERE` 子句或 `JOIN` 子句对前缀列指定了常量，则可以弥补索引的不足。满足索引扫描排序的查询，`Explain` 的 `Type` 列可以看到 `index` 信息。

#### 避免冗余索引

如果已经创建了索引 `(A,B)`，再创建索引 `(A)` 就是冗余索引，因为这是前一个索引的前缀索引，`(A,B)` 可以当做 `(A)` 来用。应尽量扩展已有的索引而不是创建新的索引。一般来说，增加新的索引会导致增删改操作的速度变慢。

#### 索引和锁

索引让查询锁定更少的行，但是锁定行仍然会带来额外的开销。锁定超过需要的行会增加锁争用并减少并发性。`InnoDB` 只有在访问行的时候才会对其加锁，而索引可以在存储引擎层减少访问的行数。如果某些行依靠索引无法过滤，那么存储引擎检索到数据并返回给服务器层后才能应用 `WHERE` 子句，而此时无法避免锁定行了。

#### 使用IN覆盖字段

为了重用索引，针对不在 `WHERE` 子句中的列，可以通过 `IN` 的方式拼接来完成最左前缀匹配（将此字段所有可能的值添加进 `IN` 列表，相当于多个等值查询进行组合）。但是如果 `IN` 的数量太多会极大地降低查询性能；并且不是所有范围查询都可以转换为 `IN` 查询，使用 `BETWEEN AND` 或大于、小于、不等于会导致索引断裂。

#### 总结

- 单行访问是很慢的，随机 `I/O` 读取的数据块应尽包含尽可能多所需要的行。使用索引创建位置引用以提升效率。
- 按顺序访问范围数据是很快的，因为顺序 `I/O` 不需要多次磁盘寻道并且如果能够按顺序读取数据，就不需要额外的排序操作。
- 索引覆盖查询是很快的，如果一个索引包含了查询需要的所有列，就不需要回表二次扫描，避免了大量的单行访问。
- 查询语句应尽可能选择合适的索引以避免单行查找；尽可能使用原生顺序从而避免额外的排序操作。

## 查询性能优化

### 优化数据访问

查询性能低下最基本的原因是访问的数据太多，大部分这样的查询都可以通过减少访问的数据量来进行优化。

- 确认应用程序是否在检索大量超过需要的数据。
- 确认 `MySQL` 服务器层是否在分析大量超过需要的数据行。

#### 避免查询不必要的数据

- 适用 `LIMIT` 避免查询不必要的行。
- 只查询需要的字段而不是使用 `SELECT *`。取出全部列会让优化器无法完成覆盖索引这类优化，还会为服务器带来额外的 `I/O`、内存和 `CPU` 消耗。除非有其它考虑，如为了提高相同代码的复用性、应用到某种缓存机制等。
- 避免不断重复执行相同的查询。需要反复查询的数据，可以缓存起来以提高性能。

#### 避免扫描额外的记录

衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数。

##### 响应时间

响应时间包括服务时间和排队时间。服务时间是真正处理查询的耗时；排队时间是服务器因等待某些资源而没有真正执行查询的时间，如 `I/O` 和锁等待等。了解查询需要用到的索引以及其执行计划，然后计算大概需要多少顺序和随机 `I/O`，获得一个大概参考值来判断当前响应时间是不是一个合理值。

##### 扫描行数和返回行数

理想情况下扫描行数和返回的行数应该是相同的，但是服务器通常需要扫描多行才能生成结果集的一行。一般 `MySQL` 能够使用如下三种方式应用 `WHERE` 条件，由好到坏分别为：

- 在索引中使用 `WHERE` 条件直接过滤不匹配的记录。这是在存储引擎层完成的。
- 使用索引覆盖扫描来返回记录，无需回表二次扫描。
- 从数据表中返回记录，然后在 `MySQL` 服务器层过滤不满足条件的记录。

如果扫描行数远大于返回行数，可以通过尝试以下方法来优化：

- 使用覆盖索引。
- 改变库表结构。例如使用单独的汇总表。
- 重写复杂查询。

### 重构查询方式

#### 查询拆分

`MySQL` 从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代网络速度相对以前要快得多，无论是带宽还是延迟。有时候将一个复杂查询分解为多个简单查询在应用层组织是很有必要的。而且分解查询可以带来一定的优势，如提高缓存效率、减少锁的竞争、方便数据库拆分等。

#### 切分查询

将大查询切成小查询，使用分页去读取行数据。

### 查询执行基础

`SQL` 执行过程如下：

![SQL执行过程](D:\doc\typora\image\SQL执行过程.png)

- 客户端发送一条查询给服务器。
- 服务端先检查缓存，如果命中了缓存，则返回结果；否则进行 `SQL` 解析、预处理，再由优化器生成对应的执行计划。
- 根据优化器生成的执行计划，调用 `API` 来执行查询。
- 将结果返回给客户端。

#### MySQL 通信协议

`MySQL` 客户端和服务端之间的通信协议是半双工的，在任一时刻，客户端向服务端发送数据或服务端向客户端发送数据不可能同时发生；一个消息也无法分成小块来独立发送。

客户端用一个单独的数据包将查询发送给服务器，服务器则将响应分为多个数据包发送给客户端。对于服务器来说，查询完成后才能释放资源，所以在和客户端交互的过程中，服务器资源都是被这个查询占用的。

##### 查询状态

对于一个 `MySQL` 连接，或者说一个线程，任何时候都有一个状态，通过 `SHOW FULL PROCESSLIST` 命令可以查看连接状态。

- `Sleep`：等待客户端发送新的请求。
- `Query`：正在执行查询或正在将结果发送给客户端。
- `Locked`：在 `MySQL` 服务器层，线程正在等待表锁。
- `Analyzing and statistics`：正在收集存储引擎的统计信息，并生成查询的执行计划。
- `Copy to tmp table [on disk]`：线程正在执行查询，并将结果集复制到一个临时表。如果有 `on disk` 标记，说明 `MySQL` 正将一个内存临时表放到磁盘上。
- `Sorting result`：正在对结果集排序。
- `Sending data`：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。

#### 查询缓存

如果查询缓存是打开的，`MySQL` 会通过一个对大小写敏感的哈希来查询缓存。如果命中了缓存并且用户有访问表的全向，缓存结果就会返回给客户端。

#### 查询优化处理

##### 语法解析和预处理

首先， `MySQL` 通过关键字对 `SQL` 语句进行解析，并生成一颗对应的解析树。`MySQL` 解析器将使用语法规则验证和解析查询。

##### 查询优化器

权限验证完成后优化器会将语法树转化成最优执行计划，以下是 `MySQL` 可以处理的优化类型：

- 重新定义关联表的顺序。
- 将外连接转化为内连接。
- 通过一些等价变换来简化并规范表达式，用来合并和减少一些比较。
- 使用索引帮助优化 `MIN()` 或 `MAX()` 函数，直接读取索引的第一条记录或最后一条记录。
- 预估转化常数表达式。如关联查询时某个表仅会返回一条记录，则关联的字段的值就会转化为一个常数。
- 覆盖索引扫描。
- 子查询优化。
- 使用 `LIMIT` 等情况时提前终止查询。
- 等值条件传递。关联查询中某个表的查询字段是一个常数，且这个字段是关联字段，条件则会传递。
- `IN` 比较通过二分查找来确定列表中的值是否满足条件，复杂度为 `O(log n)`，而在有的数据库系统中 `IN` 等价于 `OR`，复杂度为 `O(n)`。

##### 数据和索引的统计信息

查询优化器在生成查询的执行计划时需要向存储引擎获取相应的统计信息。优化器根据这种信息来选择一个最优的执行计划。

##### 执行关联查询

`MySQL` 会将关联查询的一系列单个查询结果放到一个临时表，然后再重新取出临时表完成关联查询。

##### 执行计划

`MySQL` 并不会生成查询字节码来执行查询，而是生成查询的一颗指令树，然后通过存储引擎执行完成这棵指令树并返回结果。最终的执行计划包含了重构查询的全部信息。

##### 关联查询优化器

关联查询优化器会尝试在所有的关联顺序中选择一个成本最小的来执行计划树。如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能的执行计划树的成本，然后返回一个最优的执行计划。

##### 排序优化

当不能使用索引排序生成的结果的时候，`MySQL` 需要自己进行排序，如果数据量小则在内存中进行；如果数据量大则需要使用磁盘。这个过程统称为 `filesort`（文件排序）。

如果需要排序的数据量小于排序缓冲区，则使用内存进行快速排序；如果内存不够排序，那么 `MySQL` 会先将数据分块，对每个块使用快速排序，将各个块的排序结果存放在磁盘上，然后将排序好的块进行合并，最终返回排序结果。

#### 查询执行引擎

查询执行阶段只是简单地根据执行计划给出的指令逐步执行。在执行过程中，大量的操作通过执行引擎提供的接口来完成。

#### 返回结果给客户端

如果开启缓存，结果会被放到查询缓存中。数据集返回是一个增量、逐步返回的过程，一旦服务器处理完最后一个关联表，开始生成第一条结果时，`MySQL` 就可以开始向客户端返回结果集了。这样服务端无需存储太多的结果，也不会因此消耗太多内存，也可以让客户端第一时间获取返回结果。

### 查询优化器提示

如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示（`hint`）来控制最终的执行计划。

- `HIGH_PRIORITY` 和 `LOW_PRIORITY`：当多个语句同时访问某一个表时，`HIGH_PRIORITY` 会将 `SELECT` 语句重新调度到所有等待表锁以便修改数据的语句之前，或者抵消全局 `LOW_PRIORITY` 设置对 `INSERT` 语句的影响。`LOW_PRIORITY` 会让语句处于等待状态，只要队列中还有其它需要访问同一个表的语句。
- `DELAYED`：对 `INSERT` 和 `REPLACE` 有效。执行使用该提示的 `SQL` 会立即返回客户端，并将插入的行数据放入缓冲区，在表空闲时再将数据批量写入。这个提示适合需要大量写入数据但是客户端却不需要等待单条语句完成 `I/O` 的应用。
- `STRAIGHT_JOIN`：用于固定关联查询的表关联顺序。如果用在 `SELECT` 关键字之后，则查询中所有的表都按语句的顺序进行关联；如果用在两个关联表之间，则固定两个表的关联顺序。
- `SQL_SMALL_RESULT` 和 `SQL_BIG_RESULT`：对 `SELECT` 有效，它们告诉优化器对 `GROUP BY` 或 `DISTINCT` 查询如何使用临时表及排序。`SQL_SMALL_RESULT` 告诉优化器结果集会很小，可以将结果放在内存的索引临时表，以避免排序操作；`SQL_BIG_RESULT` 告诉优化器结果很大，建议使用磁盘临时表做排序操作。
- `SQL_BUFFER_RESULT`：这个提示告诉优化器将查询结果放入一个临时表，然后尽可能快地释放表锁。
- `SQL_CACHE` 和 `SQL_NO_CACHE`：提示 `MySQL` 是否应缓存查询结果集。
- `SQL_CALC_FOUND_ROWS`：加上改提示 `MySQL` 会计算除去 `LIMIT` 子句后的查询本应返回结果集的总数，最终返回的结果集仍是 `LIMIT` 的结果，而计算的总数可以通过函数 `FOUND_ROWS()` 获取。
- `FOR UPDATE` 和 `LOCK IN SHARE MODE`：用于控制 `SELECT` 语句的所机制，但只对实现了行级锁的存储引擎有效。
- `USE INDEX`、`IGNORE INDEX` 和 `FORCE INDEX`：用于提示优化器使用或不使用哪些索引。

### 优化特定类型查询

#### 优化 COUNT() 查询

`COUNT()` 函数用于统计某个列值的数量或者行数，在统计列值时要求列是非空的，使用 `COUNT(*)` 可以忽略所有的列直接统计行数。当使用 `COUNT(col)` 统计列时，如果 `col` 列不可能为 `NULL` 值，`MySQL` 会将其优化为 `COUNT(*)`。通常来说 `COUNT()` 函数需要扫描大量的行，因此很难优化。在 `MySQL` 层面还能做的只有索引覆盖扫描了。此外还可以通过使用近似值、使用汇总表方式来加快统计。

#### 优化关联查询

- 确保优化器关联顺序的第二个表的关联字段上有索引。
- 确保 `GROUP BY ` 或 `ORDER BY` 中的表达式只涉及一个表中的列，这样才有可能使用索引来优化这个过程。

#### 优化 LIMIT

在 `LIMIT` 偏移量非常大时，`MySQL` 需要扫描大量的行而仅返回少量的结果集。优化方式之一是限制分页的数量。另一个方法是先使用覆盖索引扫描，而不是所有的列，此后再做一次关联操作返回所需的数据。

## MySQL I/O 行为

有一些配置项影响着`MySQL` 怎样同步数据到磁盘以及如何做恢复操作。这些操作对性能的影响非常大，因为涉及到昂贵的 `I/O` 操作。它们也表现为性能与数据安全之间的权衡。通常，保证数据立刻并且一致地写到磁盘是昂贵的，如果能冒一点磁盘写可能没有真正持久化到磁盘的风险，就可以增加并发性和减少 `I/O` 等待。

![InnoDB缓存和文件](D:\doc\typora\image\InnoDB缓存和文件.jpg)

### InnoDB 事务日志

`InnoDB` 使用日志来减少提交事务时的开销。日志中已经记录了事务，就无须在每个事务提交时将缓冲池的脏块刷新到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置，这意味着刷新到磁盘需要很多随机 `I/O`。`InnoDB` 事务日志将会由顺序 `I/O` 写入磁盘，一旦事务日志写入磁盘，事务就安全了，即使变更还没写到数据文件，此时如果发生宕机等事故，可以通过事务日志来恢复已提交的事务。

当然，`InnoDB` 最后还是必须把变更写到数据文件，因为日志有固定的大小。`InnoDB` 的日志是环形方式写入的：当写到日志的尾部，会重新跳转到开头继续写，但不会覆盖还没应用到数据文件的日志。刷新变更到数据文件是通过一个后台线程实现的，这个线程可以批量组合写入，使得数据写入更顺序，以提升效率。实际上，事务日志把数据文件的随机 `I/O` 转换为几乎顺序的日志文件和数据文件 `I/O`。把刷新操作转移到后台使查询可以更快完成，并且缓和查询高峰时 `I/O` 系统的压力。

要确定日志文件的大小，必须权衡正常数据变更的开销和崩溃恢复需要的时间。如果日志太小，`InnoDB` 必须做更多的检查点，导致更多的日志写，在个别情况下，在日志没有空间继续写入前，必须等待变更应用到数据文件，这样可能会拖累写语句；如果日志太大了，在崩溃恢复时 `InnoDB` 可能不得不做大量的工作，这可能极大地增加恢复时间。

当 `InnoDB` 变更任何数据时，会写一条变更记录到内存日志缓冲区（默认 `1M`）。在缓冲满的时候、事务提交的时候或者每一秒钟，`InnoDB` 都会刷新缓冲区内容到磁盘日志文件。日志缓冲必须被刷新到持久化存储，以确保提交的事务完全被持久化了。如果和持久化相比更在乎性能，可以通过 `innodb_flush_log_at_trx_commit` 变量来控制日志缓冲刷新的频繁程度，可能的设置如下：

- `0`：延迟写刷。每秒刷新一次，把日志缓冲写到日志文件，并同步刷到磁盘，事务提交不会触发。如果 `MySQL` 进程挂了，会丢失部分事务。
- `1`：实时写刷。每次事务提交都会把日志缓冲写到日志文件并刷到磁盘。这是默认设置，也是最安全的设置，可以保证不会丢失任何已提交的事务，除非磁盘或操作系统是伪刷新（刷新到磁盘缓冲区）。
- `2`：实时写，延迟刷。每次提交都会把日志缓冲写到日志文件，但是并不刷到磁盘，`InnoDB` 每秒做一次刷新。如果 `MySQL` 进程挂了，不会丢失任何事务；如果整个服务器挂了，则还是会丢失一些事务。

## Explain

### Explain 中的列

#### id 列

- `id` 值相同，则按由上到下的顺序执行。
- `id` 值不同，值越大执行顺序越靠前。

### select_type 列

显示对应行是简单还是复杂查询。`SIMPLE` 表示查询不包括子查询和 `UNION`。如果查询由任何复杂的子部分，则最外层部分标记为 `PRIMARY`，其他部分标记如下：

- `SUBQUERY`：包含在 `SELECT` 列表中的子查询中的 `SELECT`（不在 `FROM` 语句中）标记为 `SUBQUERY`。
- `DERIVED`：包含在 `FROM` 子句的子查询中的 `SELECT`。
- `UNION`：`UNION` 中的第二个和随后的 `SELECT` 被标记为 `UNION`。
- `UNION RESULT`：用来从 `UNION` 的匿名临时表检索结果的 `SELECT` 语句。 

### table 列

显示对应行正在访问哪个表的表名或者表别名。

### type 列

数据访问类型，即 `MySQL` 决定如何查找表中的行。

- `ALL`：全表扫描。
- `index`：遍历索引树。如果 `Extra` 列中标明 `Using index` 则表示使用了覆盖索引，相比按索引次序全表扫描的开销要少很多。
- `range`：索引范围扫描。它开始于索引的某一点，返回匹配这个值域的行。
- `ref`：使用非唯一索引或唯一索引的非唯一性前缀扫描。
- `eq_ref`：使用主键或唯一索引全部列访问。它将会与某个参考值比较，最多返回一条记录。
- `const`、`system`：查询的某部分可以优化并被转化为一个常量。
- `NULL`：无需访问表或索引，直接定位行。

### possible_key 列

显示查询可以使用哪些索引。

### key 列

显示 `MySQL` 决定采用哪个索引来优化对该表的访问。

### key_len 列

显示索引使用的字节数，如果使用的只是索引里的某些列，那么就可以用这个值来计算具体使用了哪些列。

### ref 列

显示 `key` 列记录的索引中查找值所用的列或常量。

### rows 列

`MySQL` 估计为了找到所需的行而要读取的行数。

### Extra 列

显示查询的额外信息，常见重要的值如下：

- `Using index`：`MySQL` 将使用覆盖索引。

- `Using where`：`MySQL` 服务器将在存储引擎检索行后再进行过滤。
- `Using temporary`：对查询结果排序时会使用一个临时表。
- `Using filesort`：会对结果集使用一个外部索引排序，而不是按索引次序从表里读取行。
- `Using where; Using index`：查询的列被索引覆盖，`WHERE` 语句的筛选条件的列也都在索引中，但不是索引的最左前缀。
- `Using index condition`：查询的列不全被索引覆盖。先使用索引扫描获取覆盖的列，再延迟读取其它未被覆盖的列。
- 无额外信息：查询的列未被索引覆盖，但是 `WHERE` 筛选条件使用了索引。













