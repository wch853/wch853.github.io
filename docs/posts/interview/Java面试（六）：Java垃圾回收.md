# Java面试（六）：Java垃圾回收

## 对象被判定为垃圾的标准

### 引用计数算法

引用计数算法通过判断对象的引用数量来决定对象是否可以被回收。每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1。任何引用计数都为0的对象实例都可以被当做垃圾收集。

- 优点：执行效率高，程序执行受影响小
- 缺点：无法检测出循环引用的情况，容易导致内存泄漏

### 可达性分析算法

可达性分析算法通过判断对象的引用链是否可达来决定对象是否可以被回收。引用链从 `GC ROOTS` 向下搜索，如果某个对象不在任何引用链上，则可被判定为回收。

可以作为 `GC ROOTS` 的对象：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法区中常量、类静态属性引用的对象
- 本地方法栈中 `JNI(native)` 方法的引用对象
- 活跃线程中的对象

## 垃圾回收算法

### 标记-清除算法（Mark and Sweep）

- 标记：从根集合进行扫描，对存活的对象进行标记
- 清除：对堆内存从头到尾进行线性遍历，回收不可达对象

- 缺点：回收会产生大量不连续的内存空间碎片，在为较大的对象分配内存空间时可能因找不到足够大的连续内存空间而触发另一次垃圾回收

### 复制算法（Copying）

复制算法将内存划分为两个内存空间，在某一时刻，对象只能分配在其中一块空间（活跃空间），而另一块空间（空闲空间）是空闲的，当进行垃圾回收时，`GC` 线程会将活跃空间内所有存活的对象复制到空闲空间，且严格按照内存地址依次排列，同时存活对象的引用地址会指向新的内存地址。活跃空间中剩余的对象被垃圾回收，活跃空间成为空闲空间，而原来的空闲空间成为活跃空间。

- 优点：解决了内存碎片化的问题；顺序分配内存，简单高效；适用于对象存活率不高的场景
- 缺点：在对象存活率较高的情况下，复制算法的效率就会降低；复制算法造成了一半内存空间的浪费

### 标记-整理算法（Compacting）

标记-整理算法从根集合进行扫描，对存活的对象进行标记，在垃圾回收时将存活的对象移动到内存的一端依次排列，移动完成后将其它内存空间的对象空间回收。

- 优点：避免了内存碎片化；不需要浪费一半的内存空间；适用于内存存活率较高的场景
- 缺点：在标记-整理算法的基础上还进行了对象移动，成本更高

### 分代收集算法

按照对象生命周期的不同使用不同的垃圾算法。

## GC 分类

- `Minor GC`：年轻代垃圾回收
- `Full GC`：老年代垃圾回收，伴随着年轻代垃圾收集

### 年轻代

年轻代分为 `Eden` 区和两个 `Survivor` 区，新对象一般分配在 `Eden` 区或其中一块 `Survivor` 区，触发 `Minor GC` 后，存活的对象会被复制到空闲的 `Survivor` 区，`Eden` 区的原来活动的 `Survivor` 区中剩余的对象会被垃圾回收。

### 老年代

一般存放生命周期较长的对象和大对象，采用标记-清除算法或标记-整理算法进行垃圾回收。`Full GC` 的速度慢得多，频率低。

### 对象如何晋升到老年代

- 经历一定 `Minor GC` 次数后依然存活的对象
- `Survivor` 中存放不下的对象
- 新生成的大对象直接在老年代中分配内存

### 触发 Full GC 的情况

- 老年代空间不足
- 在永久代存在的版本中，永久代空空间不足
- `Minor GC` 晋升到老年代的平均大小大于老年代的剩余空间
- 调用 `System.gc()`

## 垃圾收集器

![垃圾收集器搭配关系](/img/interview/垃圾收集器搭配关系.png)

### Serial  收集器

- 复制算法
- 单线程收集，垃圾回收必须暂停所有工作线程
- 是 `Client` 模式下的默认年轻代垃圾收集器

### ParNew 收集器

- 复制算法
- 多线程收集，垃圾回收必须暂停所有工作线程
- 在多核下执行效率才会优于 `Serial` 垃圾收集器

### Parallel Scavenge 收集器

- 复制算法
- 多线程收集
- 比起关注用户线程停顿时间，更关注系统的吞吐量（即运行用户代码的时间占运行总时间的比例）
- 在多核下执行才有优势，是 `Server` 模式下的默认年轻代垃圾收集器

### Serial Old 收集器

- 标记-整理算法
- 单线程收集，垃圾回收必须暂停所有工作线程
- 简单高效，是 `Client` 模式下的默认老年代收集器

### Parallel Old 收集器

- 标记-整理算法
- 多线程，吞吐量优先

### CMS 收集器

- 标记-清除算法
- GC过程短暂停，适合对时延要求较高的服务，用户线程不需要长时间的停顿

### G1 收集器

- 复制算法、标记-整理算法
- 使用多个 `CPU` 缩短垃圾收集的时间，与用户线程并发执行
- 使用不同算法对年轻代和老年代进行垃圾收集
- 空间整合，避免了产生空间碎片
- 可预测的停顿，可以限定在某个时间范围内的垃圾收集停顿时间

## finalize() 方法

`finalize() ` 方法的执行是不确定的，在可达性分析中，一个对象被宣告死亡至少需要经过两次标记，如果对象没有引用链，会被第一次标记；如果被标记对象重载了 `finalize()` 方法且未被执行过，就会被放置于 `F-Queue` 队列中，一个低优先级的线程会去触发 `finalize()` 方法，在此方法中可以觉得对象是否真正需要被回收，但是方法执行随时可能被终止。

## 引用

- 强引用：通过 `new` 关键字等方式创建出的引用，在抛出 `OutOfMemmoryError` 也不会回收强引用的对象，可以将对象设置为 `null` 使其被回收。
- 软引用：对象处在有用但非必须的状态。只有当内存空间不足，`GC` 才会回收该对象的内存，可以用来实现内存敏感的高速缓存。
- 弱引用：发生 `GC` 即会被回。
- 虚引用：在任何时候都有可能被垃圾回收，主要用来跟踪对象被垃圾收集器回收的活动，起哨兵作用，必须和引用队列 `ReferenceQueue` 联合使用。

