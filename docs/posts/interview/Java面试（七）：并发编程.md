# Java面试（七）：并发编程

## 进程和线程

进程是资源分配的最小单位，线程是 `CPU` 调度的最小单位。

- 所有与进程相关的资源，都被记录在 `PCB` 中（描述信息、控制信息、资源信息、`CPU` 现场）
- 进程是抢占处理机的调度单位，线程属于某个进程，共享其资源
- 线程只由堆栈寄存器、程序计数器和 `TCB` 组成

## Java 中的线程

### 线程返回值

- `Callable` + `FutureTask`，通过线程执行
- 创建线程池，通过 `submit` 提交任务

### 线程状态

- `NEW`：创建后尚未启动的线程状态
- `Runnable`：运行状态，包含 `Running` 和 `Ready`
- `Waiting`：无限期等待，不会被分配 `CPU` 执行时间，需要显式地被唤醒
- `Timed Waiting`：有限期等待，需要被显式地唤醒或在一定时间后由系统自动唤醒
- `Blocked`：阻塞状态，等待获取排它锁
- `Terminated`：线程终止执行

### sleep 和 wait

- `sleep()` 是 `Thread` 类的方法，`wait()` 是 `Object` 类的方法
- `sleep()` 可以在任何地方使用，`wait()` 方法只能在 `synchronized` 语句块内使用
- `sleep()` 只会让出 `CPU`，不会导致锁行为的改变，`wait()` 方法不仅会让出 `CPU` 资源，还会释放持有的锁资源

### notify 和 notifyAll

- 锁池：对象的锁已被某个线程持有，则其它想要获得这个对象的锁的线程就会进入锁池等待锁的释放
- 等待池：某个线程调用了对象的 `wait()` 方法，则会释放这个线程的锁，并进入该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁。

- 调用 `notify()` 方法会从等待池中随机选取一个等待池中的线程进入锁池去竞争锁
- 调用 `notifyAll()` 方法会让等待池中所有的线程进入锁池去竞争锁

### yield

调用 `yield()` 表示当前线程愿意让出 `CPU`

### interrupt

通过调用 `interrupt()` 方法可以通知线程应当中断：

- 如果线程处于阻塞状态，那么线程会立即退出阻塞状态并抛出 `InterruptedException`，如果捕捉了此异常，线程中断标志会被清除
- 如果线程处于正常活动的状态，线程会被打上中断标志，并继续正常运行
- 如果需要根据中断退出线程，则需要显式指定当线程中断标志为 `true`  时退出线程

## Synchronized

### 互斥锁的特性

- 互斥性：即在同一时刻只允许一个线程持有某个对象锁，这样在同一时刻只有一个线程对需要同步的代码块进行访问。互斥性也成为操作的原子性。
- 可见性：必须确保在锁释放之前，当前线程对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的。

### 自旋锁

在许多情况下，共享数据的锁定状态持续时间较短，切换线程是不值得的，因此可以通过执行忙循环的方式不让出 `CPU`，但是如果忙循环长时间执行，则可能会带来更多性能上的开销。

### 锁消除

`JIT` 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。

### 锁粗化

一系列操作对同一个对象反复加锁，通过扩大锁的范围对锁粗话，避免反复加锁增加的开销。

### 偏向锁

如果某个线程获取了锁，到再次请求锁时，没有其他线程再去请求该锁，则省略线程申请锁的同步操作。

###  轻量级锁

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 `Mark Word` 复制到锁记录中，然后线程尝试使用 `CAS` 将对象头中的 `Mark Word` 替换为指向锁记录的指针。如果成功则线程可以顺利进入临界区，如果失败，锁请求会膨胀为重量级锁

![锁优缺点和使用场景](/img/interview/锁优缺点和使用场景.png)

## ReentrantLock

## Java 内存模型

### 工作内存

- 存储当前方法的所有本地变量信息，本地变量对其它线程不可见。
- 字节码行号指示器、`native` 方法信息
- 线程私有，不会造成线程安全问题

