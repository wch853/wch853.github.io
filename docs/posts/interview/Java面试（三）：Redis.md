# Java面试（二）：Redis

## Redis

- 数据类型丰富
- 支持数据磁盘持久化存储
- 支持主从
- 支持分片

### 为什么Redis这么快

- 完全基于内存，绝大部分请求纯粹是内存操作，执行效率高
- 数据结构和对数据的操作简单
- 采用单线程，避免了频繁创建和销毁线程以及切换上下文带来的开销，没有锁竞争
- 使用 `I/O` 多路复用模型

### 检索 key

检索 `key` 可以使用 `keys pattern` 命令返回全部匹配的 `key`，但是数据量大时可能会阻塞其它操作。使用 `scan` 命令可以实现分批检索 `key`：

```bash
SCAN cursor [MATCH pattern] [COUNT count]
```

初始命令给定一个起始 `cursor` 用于指定数量地模糊匹配 `key`，如果在指定的 `count` 内没有返回全部的匹配的 `key` 则会返回一个游标用于下一次检索，直到返回的游标为0。

### Redis 分布式锁

#### 分布式锁需要解决的问题

- 互斥性：任意时刻只能有一个客户端获取到锁
- 安全性：锁只能被持有锁的客户端删除
- 死锁：在某个客户端因为故障不能释放锁，需要采取措施避免死锁
- 容错：部分 `Redis` 节点故障，客户端仍能获取到锁

 #### Redis 实现

```bash
SET key value [EX seconds] NX
```

`NX` 指令表示指定 `key` 不存在才进行操作，否则返回 `nil`。多个客户端可以通过设置相同的 `key` 值来获取分布式锁，为了避免死锁，需要设置过期时间。

### Redis 持久化

#### RDB（快照）持久化

`RDB` 通过保存某个时间点的全量数据快照来进行持久化，数据量大时会由于 `I/O` 而严重影响性能，最近一次快照后的数据有可能会丢失，但是恢复数据的速度快。

- `SAVE`：阻塞 `Redis` 主进程，直到 `RDB` 文件创建完成，这种方式会阻塞所有客户端请求。
- `BGSAVE`：`Fork` 出一个子进程来创建 `RDB` 文件，不会阻塞客户端请求。

#### AOF（Append-Only-File）持久化

`AOF` 持久化通过记录除查询以外的所有变更指令来实现持久化，变更命令会通过文件追加的方式增量写入 `AOF` 文件。`AOF` 文件会因不断写入命令不断增大，`Redis` 会重写日志文件，即根据已有的数据内容生成新的 `AOF` 文件，替换原来的文件。`AOF` 持久化的方式适合保存增量数据，数据不易丢失，但是文件体积大，恢复时间长。

#### RDB-AOF 混合持久化

通过 `BGSAVE` 做全量持久化，`AOF` 做增量持久化。

### Redis 主从同步

#### 全同步

- 从节点发送同步请求给主节点
- 主节点执行 `BGSAVE`，保存全量数据快照，并在快照生成期间将增量变更命令缓存起来
- 主节点保存全量数据快照完成后将文件发送给从节点
- 从节点保存快照文件并加载到内存中
- 主节点将增量变更发送给从节点

### Redis Sentinel

`Redis Sentinel（哨兵）` 用于解决主节点宕机后的主从切换问题。 

- 监控：检查主从服务器是否正常运行
- 提醒：通过 `API` 向管理员或其它应用程序发送故障通知
- 自动故障迁移：主从切换

### Redis 集群

对 `key` 做一致性 `hash`