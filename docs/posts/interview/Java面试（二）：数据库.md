# Java面试（二）：数据库

## 关系型数据库

- 文件系统：将数据持久化到硬盘中。
- 存储管理：对数据格式、文件分隔等进行统一管理，即把物理数据通过逻辑的形式组织和表示出来。
- 缓存管理：将读取的数据块加载到缓存中，下次读取直接从缓存中返回，避免频繁与硬盘发生 `I/O`。
-  `SQL` 解析：将用户 `SQL` 语句进行解析，进行相应的操作。
- 日志管理：记录操作日志，方便主从同步、灾难恢复等。
- 权限管理：各个用户的操作权限应该被限制。
- 容灾机制：如何恢复。
- 索引管理：
- 锁管理：

## 索引

### 为什么使用索引

全表扫描的方式将整张表的数据全部或分批次加载到内存中，然后对逐个块（页）进行查询。这种查询方式在数据量小的时候是比较高效的，在数据量大时则需要尽可能避免。而查询额外维护的索引文件则可以很快定位到数据所在的块（页），从而大幅提升了查询速度。

### 什么样的信息能成为索引

主键、唯一键和普通键等。

### 索引的数据结构

- `BTREE`
- `B+TREE`

### 稠密索引和稀疏索引

- 搜索码：用于在文件中查找记录的属性或属性集。

- 稠密索引：每个搜索码对应一个索引值，索引项包括索引值以及指向该搜索码值的第一条数据记录的指针，可以很快的定位记录。
- 稀疏索引：只为搜索码的某些值建立索引，索引项为关键字和主键的值。比如稀疏索引为每个数据块建立一个索引，数据块意味着内存单元连续。稀疏索引占用空间更小，修改记录所需维护的开销也小。

### 慢查

- 根据慢查日志定位
  - 修改 `slow_query_log` 为 `on` 来开启慢查日志。
  - 修改 `slow_query_log_file` 定义慢查日志文件位置，默认在 `data` 目录下。
- 使用 `explain` 等工具分析 `SQL`
  - `id`：表示执行 `SQL` 语句的顺序，值越大，越先被执行。
  - `select_type`：每个查询子句的类型。是简单查询还是包含子查询的复杂查询。
  - `type`：访问类型。性能 `ALL（全表扫描） < INDEX（遍历索引树） < RANGE（索引范围扫描） < REF（索引前缀扫描） < EQ_REF（唯一索引） < CONST（查询转常量） < SYSTEM（特殊 Const） < NULL（无需访问索引直接定位）` 。
  - `possible_keys`：查询可能使用到的索引。
  - `key`：实际使用的索引。
  - `key_len`：索引使用的字节数，可用于计算使用的索引的长度。
  - `ref`：哪些列或常量被用于查找索引列上的值。
  - `row`：估算找到所需记录扫描的行数。
  - `Extra`：额外的重要信息。出现 `Using filesort` 或 `Using temporary` 意味着根本不能使用索引，应尽可能对查询进行优化。
- 修改 `SQL` 尽量使查询走索引。

### 联合索引最左匹配原则

对于联合索引，数据库会一直向右匹配直到遇到范围查询（`>`、`<`、`between`、`like`）停止匹配。如建立索引为 `(a, b, c, d)`，查询条件为 `a = 1 and b = 2 and c > 3 and d = 4 `，则 `d` 匹配不到索引，而如果建立索引 `(a, b, d, c)` 则全部可以匹配并且 `a、b、d` 可以乱序。

联合索引在建立的时候，会依次对索引中的字段进行排序，也就是在前一个字段排序的基础上对下一个字段进行排序，因此第一个字段是绝对有序的，如果查询语句不从最左开始匹配，是无法使用索引的。

### 索引不是越多越好

- 表数据量小时不需要建立索引，维护索引会增加不必要的开销。
- 数据变更需要维护索引，更多索引意味着更高的维护成本。
- 更多的索引需要更多的存储空间。

## 锁

### 锁的分类

- 按锁的粒度划分：表级锁、行级锁、页级锁
- 按锁的级别划分：共享锁和排它锁
- 按锁的方式划分：自动锁、显示锁
- 按操作划分，可分为 `DML` 锁、`DDL` 锁
- 按使用方式划分，可分为乐观锁和悲观锁

### 共享锁与排它锁

- 共享锁（`IS`）：又称读锁，可以被多个线程同时持有。
- 排它锁（`IX`）：又称写锁、独占锁，同一时刻只能被一个线程所持有。

#### 兼容性

| 锁类型 | X    | S     |
| ------ | ---- | ----- |
| X      | 冲突 | 冲突  |
| S      | 冲突 | j兼容 |

### MySQL 引擎

#### MyISAM 

`MyISAM` 默认使用表级锁，不支持行级锁。

- 适合频繁执行全表 `count` 语句（变量保存，直接读取）的场景。
- 适合查询频繁，增删改频率不高的场景。
- 适合不需要使用事务的场景。

#### InnoDB 

`InnoDB` 默认使用行级锁，也支持表级锁。

- 适合数据增删改查都很频繁的场景。
- 适合对可靠性要求比较高，要求支持事务的场景。

### 事务

#### ACID

- `Atomic`
- `Consistency`
- `Isolation`
- `Durability`

#### 当前读和快照读

- 当前读：读取的是数据的最新版本，并且返回的记录都会加上锁，保证其它事务不会修改当前记录。
- 快照读：读取的是数据的可见版本（可能是历史数据），不用加锁。

#### next-key 锁（行锁 + Gap锁）

##### Gap 锁（间隙锁）

对索引间可插入数据的间隙加锁，避免出现幻读。`Gap` 锁会用在非唯一索引或不走索引的当前读中。  

##### 使用条件

- 如果 `where` 条件全部命中则只会使用行锁。
- 如果 `where` 条件部分命中或全部不命中，则会加 `Gap` 锁。

