(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{215:function(a,t,s){"use strict";s.r(t);var e=s(0),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"并发编程（三）：锁的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发编程（三）：锁的优化"}},[a._v("#")]),a._v(" 并发编程（三）：锁的优化")]),a._v(" "),s("h2",{attrs:{id:"锁优化角度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁优化角度"}},[a._v("#")]),a._v(" 锁优化角度")]),a._v(" "),s("h3",{attrs:{id:"减小锁持有的时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#减小锁持有的时间"}},[a._v("#")]),a._v(" 减小锁持有的时间")]),a._v(" "),s("p",[a._v("在真正需要同步的代码块进行加锁，避免在整个任务的处理上加锁，有助于降低锁冲突的可能性，进而提升系统的并发能力。")]),a._v(" "),s("h3",{attrs:{id:"减小锁粒度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#减小锁粒度"}},[a._v("#")]),a._v(" 减小锁粒度")]),a._v(" "),s("p",[a._v("缩小锁定对象的范围，降低锁冲突可能性，进而提升系统并发能力。例如 "),s("code",[a._v("ConcurrentHashMap")]),a._v(" 内部细分为若干个小的 "),s("code",[a._v("HashMap")]),a._v("，添加数据时可能只需要对其中的某个 "),s("code",[a._v("SEGMENT")]),a._v(" 加锁，这样同时就有多个线程可以操作 "),s("code",[a._v("ConcurrentHashMap")]),a._v("，大大提高了吞吐量。")]),a._v(" "),s("h3",{attrs:{id:"使用读写锁代替独占锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用读写锁代替独占锁"}},[a._v("#")]),a._v(" 使用读写锁代替独占锁")]),a._v(" "),s("p",[a._v("理论上读-读之前是不应该阻塞的，在读多写少的情况下，使用读写锁相对于独占锁能够有效提升系统并发能力。")]),a._v(" "),s("h3",{attrs:{id:"锁分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁分离"}},[a._v("#")]),a._v(" 锁分离")]),a._v(" "),s("p",[a._v("在区别读写锁的基础上进一步延伸，就是锁分离。例如如果需要创建一个线程安全的容器，其加入元素和弹出元素的操作必须要获得容器的锁，那么在运行时，加入和弹出操作就必须等待对方释放资源，如果锁竞争激烈，并发性能就会大大下降。而 "),s("code",[a._v("LinkedBlockingQueue")]),a._v(" 的实现中，则使用了读锁和写锁两把锁，其原理是利用 "),s("code",[a._v("ReentrantLock")]),a._v(" 和 "),s("code",[a._v("Condition")]),a._v(" 分别阻塞和唤醒线程，使得读取和写入之间可以并发。")]),a._v(" "),s("h3",{attrs:{id:"锁粗化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁粗化"}},[a._v("#")]),a._v(" 锁粗化")]),a._v(" "),s("p",[a._v("虚拟机在一系列对同一锁不断进行请求和释放的操作时，便会把所有锁操作整合为对锁的一次请求，从而减少对锁的请求同步次数。锁粗化的思想和减少锁的持有时间是相反的。")]),a._v(" "),s("h2",{attrs:{id:"jvm-对锁的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm-对锁的优化"}},[a._v("#")]),a._v(" JVM 对锁的优化")]),a._v(" "),s("h3",{attrs:{id:"偏向锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁")]),a._v(" "),s("p",[a._v("如果某个线程获取了锁，到再次请求锁时，没有其他线程再去请求该锁，则省略线程申请锁的同步操作。在几乎没有锁竞争的场合中，偏向锁具有很强的优化效果；但在锁竞争激烈的情况下，可能是多个线程请求相同的锁，偏向模式就会失效。通过虚拟机参数 "),s("code",[a._v("-XX:+UseBiasedLocking")]),a._v(" 开启偏向锁。")]),a._v(" "),s("h3",{attrs:{id:"轻量级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[a._v("#")]),a._v(" 轻量级锁")]),a._v(" "),s("p",[a._v("线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 "),s("code",[a._v("Mark Word")]),a._v(" 复制到锁记录中，然后线程尝试使用 "),s("code",[a._v("CAS")]),a._v(" 将对象头中的 "),s("code",[a._v("Mark Word")]),a._v(" 替换为指向锁记录的指针。如果成功则线程可以顺利进入临界区，如果失败，锁请求会膨胀为重量级锁。")]),a._v(" "),s("h3",{attrs:{id:"自旋锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[a._v("#")]),a._v(" 自旋锁")]),a._v(" "),s("p",[a._v("假设在不久的将来，线程就可以获取请求的锁资源，那么直接在操作系统层面将线程挂起是得不偿失的，因此虚拟机会让当前线程做几个空循环，如果若干次循环后能够获得锁，则顺利进入临界区，否则才会将线程真实地在操作系统层面挂起。")]),a._v(" "),s("h3",{attrs:{id:"锁消除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[a._v("#")]),a._v(" 锁消除")]),a._v(" "),s("p",[a._v("虚拟机在 "),s("code",[a._v("JIT")]),a._v(" 编译时通过对上下文的扫描，能够去除不可能存在共享资源竞争的锁。通过锁消除，可以节省无意义的请求锁的时间。锁消除设计的一项关键技术为逃逸分析，即观察某一个变量是否会逃出某一个作用域。")]),a._v(" "),s("h2",{attrs:{id:"threadlocal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[a._v("#")]),a._v(" ThreadLocal")]),a._v(" "),s("p",[s("code",[a._v("ThreadLocal")]),a._v(" 表示线程局部变量，只有当前线程才能访问，因此是线程安全的，但是不同线程的 "),s("code",[a._v("ThreadLocal")]),a._v(" 如果存放了相同的对象，那么也是线程不安全的，需要在应用层作出保证。如果共享对象对于竞争的处理容易造成性能损失，则应该考虑使用 "),s("code",[a._v("ThreadLocal")]),a._v(" 为每个线程分配单独的对象。")]),a._v(" "),s("h3",{attrs:{id:"threadlocal-set-t-value"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-set-t-value"}},[a._v("#")]),a._v(" ThreadLocal.set(T value)")]),a._v(" "),s("p",[a._v("在调用 "),s("code",[a._v("ThreadLocal")]),a._v(" 的 "),s("code",[a._v("set()")]),a._v(" 方法时，先根据当前线程获取 "),s("code",[a._v("ThreadLocal.ThreadLocalMap")]),a._v(" 的一个实例（可以理解为一个 Map），写入数据时，以 "),s("code",[a._v("ThreadLocal")]),a._v(" 对象作为 "),s("code",[a._v("key")]),a._v("，写入的数据作为 "),s("code",[a._v("value")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"threadlocal-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-get"}},[a._v("#")]),a._v(" ThreadLocal.get()")]),a._v(" "),s("p",[a._v("在调用 "),s("code",[a._v("ThreadLocal")]),a._v(" 的 "),s("code",[a._v("get()")]),a._v(" 方法时，获取当前线程对应的 "),s("code",[a._v("ThreadLocal.ThreadLocalMap")]),a._v(" 实例，再使用 "),s("code",[a._v("ThreadLocal")]),a._v(" 对象作为 "),s("code",[a._v("key")]),a._v(" 取出数据。")]),a._v(" "),s("h3",{attrs:{id:"threadlocal-remove"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-remove"}},[a._v("#")]),a._v(" ThreadLocal.remove()")]),a._v(" "),s("p",[a._v("通过 "),s("code",[a._v("ThreadLocal")]),a._v(" 写入的数据是维护在线程内部的，所以只要线程不退出，对象引用就会一直存在。如果使用线程池，在任务结束后不对数据进行清理，则可能会造成内存泄漏，因此在数据使用完成后最好使用 "),s("code",[a._v("ThreadLocal.remove()")]),a._v(" 将数据移除。")]),a._v(" "),s("h2",{attrs:{id:"无锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无锁"}},[a._v("#")]),a._v(" 无锁")]),a._v(" "),s("p",[a._v("对于并发而言，锁是一种悲观的策略，它总是假设每次临界区操作都会产生冲突，在获取不到锁时，会阻塞线程执行。而无锁是一种乐观的策略，它假设对资源的访问是没有冲突的，所有线程都可以在非阻塞的情况下执行，无锁策略使用 "),s("code",[a._v("CAS (Compare And Swap)")]),a._v(" 来鉴别线程冲突，一旦检测到冲突，就重试当前操作至没有冲突为止。")]),a._v(" "),s("h3",{attrs:{id:"cas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),s("p",[s("code",[a._v("CAS (Compare And Swap，比较交换)")]),a._v(" 由于其非阻塞性，对死锁问题天生免疫；线程间的相互影响远比基于锁的方式要小；使用无锁的方式完全没有锁竞争和线程间频繁调度带来的系统开销，因此无锁比基于锁的方式拥有更优越的性能。")]),a._v(" "),s("h4",{attrs:{id:"cas-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas-算法"}},[a._v("#")]),a._v(" CAS 算法")]),a._v(" "),s("p",[s("code",[a._v("CAS(V, E, N)")]),a._v(" 包含 3 个参数：")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("V")]),a._v("：要更新的变量的值。")]),a._v(" "),s("li",[s("code",[a._v("E")]),a._v("：变量的预期值。")]),a._v(" "),s("li",[s("code",[a._v("N")]),a._v("：变量需要更新的值。")])]),a._v(" "),s("p",[s("code",[a._v("CAS")]),a._v(" 是一个原子操作，仅当 "),s("code",[a._v("V")]),a._v(" 和 "),s("code",[a._v("E")]),a._v(" 相等时，才会将变量的值更新为 "),s("code",[a._v("N")]),a._v("，否则说明有其它线程对这个变量做了修改操作，当前线程放弃更新，最后返回变量的真实值。")]),a._v(" "),s("h4",{attrs:{id:"cas-核心操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas-核心操作"}},[a._v("#")]),a._v(" CAS 核心操作")]),a._v(" "),s("p",[a._v("以 "),s("code",[a._v("AtomicInteger")]),a._v(" 为例，此类中的核心字段为：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 实际取值")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[s("code",[a._v("incrementAndGet()")]),a._v(" 方法的作用是自增 1 并获取变量的值，其内部调用的是 "),s("code",[a._v("Unsafe")]),a._v(" 类的 "),s("code",[a._v("getAndAddInt()")]),a._v(" 方法。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("incrementAndGet")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" unsafe"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getAndAddInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" valueOffset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * @param obj 进行修改的AtomicInteger对象\n * @param valueOffset AtomicInteger的value字段的地址偏移量\n * @param i 要增加的数值\n * @return 被修改的变量修改前的值\n */")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getAndAddInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" valueOffset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" pre"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 需要修改的变量的当前值")]),a._v("\n        pre "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getIntVolatile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" valueOffset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// CAS操作，成功返回true，失败返回false")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("compareAndSwapInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" valueOffset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" pre"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" pre "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" pre"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[s("code",[a._v("getAndAddInt()")]),a._v(" 方法被调用后，循环调用 Java Native 方法 "),s("code",[a._v("compareAndSwapInt()")]),a._v("，如果修改成功则退出循环，返回被修改的变量修改前的值，如果修改不成功，则会一直重试直至成功修改。")]),a._v(" "),s("h4",{attrs:{id:"aba-问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aba-问题"}},[a._v("#")]),a._v(" ABA 问题")]),a._v(" "),s("p",[a._v("从内存中读取和比较之间，变量的值可能被多次修改，最终回到原来的值，当前线程可能就会误以为此变量未修改。为了解决这类问题，可以引入 "),s("code",[a._v("AtomicStampedReference")]),a._v("，它的内部不仅维护了变量的值，还维护了修改的时间戳（或者可以看作是版本号），当进行 "),s("code",[a._v("CAS")]),a._v(" 操作时，对象值和时间戳都满足期望值，修改才会成功。")]),a._v(" "),s("h4",{attrs:{id:"普通字段的原子操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#普通字段的原子操作"}},[a._v("#")]),a._v(" 普通字段的原子操作")]),a._v(" "),s("p",[a._v("原子包提供 "),s("code",[a._v("AtomicIntegerFieldUpdater")]),a._v("，"),s("code",[a._v("AtomicReferenceFieldUpdater")]),a._v(" 等工具用于给普通资源提供原子操作，其使用方式如下：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),a._v(" t "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("AtomicIntegerFieldUpdater")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" number "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("AtomicIntegerFieldUpdater")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("newUpdater")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"number"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nnumber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("incrementAndGet")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("使用这些工具需要注意：")]),a._v(" "),s("ul",[s("li",[a._v("只能增强非 "),s("code",[a._v("private")]),a._v(" 字段，即只能修改可见范围内的字段。")]),a._v(" "),s("li",[a._v("被增强的字段必须要用 "),s("code",[a._v("volatile")]),a._v(" 字段修饰，用于确保变量被正确的读取。")]),a._v(" "),s("li",[a._v("由于 "),s("code",[a._v("CAS")]),a._v(" 会通过对象实例中的偏移量直接进行赋值，所以增强不支持 "),s("code",[a._v("static")]),a._v(" 字段。")])]),a._v(" "),s("h3",{attrs:{id:"unsafe-类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unsafe-类"}},[a._v("#")]),a._v(" Unsafe 类")]),a._v(" "),s("p",[s("code",[a._v("sun.misc.Unsafe")]),a._v(" 类封装了一些不安全的操作，主要是为了操作指针，例如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("native")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" offset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("此方法的作用是获取到对象 "),s("code",[a._v("obj")]),a._v(" 头部的偏移量为 "),s("code",[a._v("offset")]),a._v(" 的 "),s("code",[a._v("int")]),a._v(" 值。")])])}),[],!1,null,null,null);t.default=n.exports}}]);