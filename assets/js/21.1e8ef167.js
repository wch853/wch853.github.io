(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{226:function(v,a,_){"use strict";_.r(a);var e=_(0),s=Object(e.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"java面试（五）：java"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java面试（五）：java"}},[v._v("#")]),v._v(" Java面试（五）：Java")]),v._v(" "),_("h2",{attrs:{id:"平台无关性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#平台无关性"}},[v._v("#")]),v._v(" 平台无关性")]),v._v(" "),_("p",[v._v("平台无关性指在计算机上运行不受平台约束。"),_("code",[v._v("Java")]),v._v(" 号称 "),_("code",[v._v("write once, run everywhere")]),v._v("，即一次编译，到处运行。对于不同的硬件和操作系统，最主要的区别就是二进制指令的不同，"),_("code",[v._v("Java")]),v._v(" 之所以能做到跨平台，就是因为虚拟机能够将 "),_("code",[v._v("javac")]),v._v(" 编译生成的字节码文件根据硬件和操作系统生成对应的二进制指令，由此实现平台无关性。")]),v._v(" "),_("h3",{attrs:{id:"反射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[v._v("#")]),v._v(" 反射")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 反射机制指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对与任意一个对象，都能够调用它的任意方法和属性。")]),v._v(" "),_("h3",{attrs:{id:"classloader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#classloader"}},[v._v("#")]),v._v(" ClassLoader")]),v._v(" "),_("p",[_("code",[v._v("ClassLoader")]),v._v(" 工作在 "),_("code",[v._v("class")]),v._v(" 装载的加载阶段，其主要作用是从系统外部获得 "),_("code",[v._v("class")]),v._v(" 的二级制数据流，然后交给 "),_("code",[v._v("Java")]),v._v(" 虚拟机进行连接、初始化等操作。")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("BootStrapClassLoader")]),v._v("："),_("code",[v._v("C++")]),v._v(" 编写，用于加载核心库 "),_("code",[v._v("Java.*")])]),v._v(" "),_("li",[_("code",[v._v("ExtClassLoader")]),v._v("："),_("code",[v._v("Java")]),v._v(" 编写，用于加载扩展库 "),_("code",[v._v("javax.*")])]),v._v(" "),_("li",[_("code",[v._v("AppClassLoader")]),v._v("："),_("code",[v._v("Java")]),v._v(" 编写，加载程序所在目录")]),v._v(" "),_("li",[v._v("自定义 "),_("code",[v._v("ClassLoader")]),v._v("："),_("code",[v._v("Java")]),v._v(" 编写，定制化加载")])]),v._v(" "),_("h4",{attrs:{id:"双亲委派机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[v._v("#")]),v._v(" 双亲委派机制")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("class")]),v._v(" 加载的过程中，下层的 "),_("code",[v._v("ClassLoader")]),v._v(" 会委派上层 "),_("code",[v._v("ClassLoader")]),v._v(" 去查询需要加载的 "),_("code",[v._v("class")]),v._v(" 是否已经被加载过。如果已经加载，则无需重新加载；如果没有加载，则希望委派上层 "),_("code",[v._v("ClassLoader")]),v._v(" 进行加载，如果不能加载，会传递给下一层的 "),_("code",[v._v("ClassLoader")]),v._v(" 进行加载。")]),v._v(" "),_("p",[v._v("通过使用双亲委派机制加载 "),_("code",[v._v("class")]),v._v("，可以避免同样的字节码被加载多份。")]),v._v(" "),_("h3",{attrs:{id:"类装载过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类装载过程"}},[v._v("#")]),v._v(" 类装载过程")]),v._v(" "),_("ul",[_("li",[v._v("加载：通过 "),_("code",[v._v("ClassLoader")]),v._v(" 将对应的字节码加载到内存中，生成 "),_("code",[v._v("Class")]),v._v(" 对象")]),v._v(" "),_("li",[v._v("验证：字节码验证，校验字节码的正确性和安全性")]),v._v(" "),_("li",[v._v("准备：为类变量分配内存并设置类变量的初始值")]),v._v(" "),_("li",[v._v("解析：将常量池中的符号引用替换为直接引用")]),v._v(" "),_("li",[v._v("初始化：执行类构造器 "),_("code",[v._v("<client>")]),v._v(" 方法，即对类变量赋值和执行静态语句块")])]),v._v(" "),_("h2",{attrs:{id:"java内存模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型"}},[v._v("#")]),v._v(" Java内存模型")]),v._v(" "),_("h3",{attrs:{id:"地址空间划分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#地址空间划分"}},[v._v("#")]),v._v(" 地址空间划分")]),v._v(" "),_("ul",[_("li",[v._v("内核空间：运行操作系统和驱动程序")]),v._v(" "),_("li",[v._v("用户空间：运行用户应用程序")])]),v._v(" "),_("h3",{attrs:{id:"运行时数据区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区"}},[v._v("#")]),v._v(" 运行时数据区")]),v._v(" "),_("h4",{attrs:{id:"程序计算器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计算器"}},[v._v("#")]),v._v(" 程序计算器")]),v._v(" "),_("p",[v._v("当前线程执行的字节码的逻辑行号指示器")]),v._v(" "),_("h4",{attrs:{id:"虚拟机栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[v._v("#")]),v._v(" 虚拟机栈")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 方法执行的内存模型，每个方法执行时都会创建栈帧，用于存储局部变量表、操作栈、动态连接，返回地址，对应每个方法从入栈到出栈的过程。")]),v._v(" "),_("h4",{attrs:{id:"方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),_("p",[v._v("方法区用于存储类的信息，在 "),_("code",[v._v("JDK1.7")]),v._v(" 及之前这部分信息存储在永久代（"),_("code",[v._v("PermGen")]),v._v("），"),_("code",[v._v("JDK1.8")]),v._v(" 后存储在元空间（"),_("code",[v._v("MetaSpace")]),v._v("）。")]),v._v(" "),_("h5",{attrs:{id:"元空间与永久代的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#元空间与永久代的区别"}},[v._v("#")]),v._v(" 元空间与永久代的区别")]),v._v(" "),_("p",[v._v("元空间使用本地内存，永久代使用的是虚拟机的内存，元空间相对于方法区存在若干优势：")]),v._v(" "),_("ul",[_("li",[v._v("字符串常量池存在永久代中，容易出现性能问题和内存溢出。")]),v._v(" "),_("li",[v._v("类和方法的信息大小难以确定，给指定永久代的大小带来困难。")]),v._v(" "),_("li",[v._v("永久代会为 "),_("code",[v._v("GC")]),v._v(" 带来不必要的复杂性")]),v._v(" "),_("li",[v._v("永久代是 "),_("code",[v._v("HotSpot")]),v._v(" 所特有的，使用元空间替代方便与其它虚拟机集成")])]),v._v(" "),_("h3",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("p",[v._v("堆（"),_("code",[v._v("Heap")]),v._v("）是对象实例的分配区域，")]),v._v(" "),_("h3",{attrs:{id:"java性能调优参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java性能调优参数"}},[v._v("#")]),v._v(" Java性能调优参数")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("-Xss")]),v._v("：规定了每个虚拟机栈（堆栈）的大小，会影响进程中所能创建的并发线程数的大小")]),v._v(" "),_("li",[_("code",[v._v("-Xms")]),v._v("：堆的初始大小")]),v._v(" "),_("li",[_("code",[v._v("-Xmx")]),v._v("：堆可以扩展到的最大容量")])]),v._v(" "),_("h3",{attrs:{id:"堆和栈的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈的区别"}},[v._v("#")]),v._v(" 堆和栈的区别")]),v._v(" "),_("ul",[_("li",[v._v("对象和数组在堆中分配内存空间，栈中定义变量保存堆中目标数据的首地址")]),v._v(" "),_("li",[v._v("栈内存在栈销毁时就可以释放，堆中内存的回收依赖 "),_("code",[v._v("GC")])]),v._v(" "),_("li",[v._v("堆内存一般远大于栈内存")]),v._v(" "),_("li",[v._v("栈产生的碎片远小于堆")]),v._v(" "),_("li",[v._v("栈支持静态分配（在编译期即可确定占用的内存空间）和动态分配，堆仅支持动态分配")]),v._v(" "),_("li",[v._v("栈的效率比堆高（栈的操作只有入栈和出栈，更为简单）")])]),v._v(" "),_("h3",{attrs:{id:"intern-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#intern-方法"}},[v._v("#")]),v._v(" intern() 方法")]),v._v(" "),_("h4",{attrs:{id:"jdk6"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk6"}},[v._v("#")]),v._v(" JDK6")]),v._v(" "),_("p",[v._v("常量池在方法区中，调用 "),_("code",[v._v("intern")]),v._v(" 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该对象的引用，否则将此字符串对象添加到字符串常量池中，并返回池中该对象的引用。方法区大小是有限的，频繁调用 "),_("code",[v._v("intern")]),v._v(" 方法可能会导致内存溢出。")]),v._v(" "),_("h4",{attrs:{id:"jdk6-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk6-2"}},[v._v("#")]),v._v(" JDK6+")]),v._v(" "),_("p",[v._v("常量池在堆中，调用 "),_("code",[v._v("intern")]),v._v(" 方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该对象的引用。否则如果该字符串对象已经存在于 "),_("code",[v._v("Java")]),v._v(" 堆中，则将堆中此对象的引用添加到字符串常量池中并返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。")])])}),[],!1,null,null,null);a.default=s.exports}}]);