(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{224:function(v,_,a){"use strict";a.r(_);var t=a(0),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"java面试（七）：并发编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java面试（七）：并发编程"}},[v._v("#")]),v._v(" Java面试（七）：并发编程")]),v._v(" "),a("h2",{attrs:{id:"进程和线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[v._v("#")]),v._v(" 进程和线程")]),v._v(" "),a("p",[v._v("进程是资源分配的最小单位，线程是 "),a("code",[v._v("CPU")]),v._v(" 调度的最小单位。")]),v._v(" "),a("ul",[a("li",[v._v("所有与进程相关的资源，都被记录在 "),a("code",[v._v("PCB")]),v._v(" 中（描述信息、控制信息、资源信息、"),a("code",[v._v("CPU")]),v._v(" 现场）")]),v._v(" "),a("li",[v._v("进程是抢占处理机的调度单位，线程属于某个进程，共享其资源")]),v._v(" "),a("li",[v._v("线程只由堆栈寄存器、程序计数器和 "),a("code",[v._v("TCB")]),v._v(" 组成")])]),v._v(" "),a("h2",{attrs:{id:"java-中的线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-中的线程"}},[v._v("#")]),v._v(" Java 中的线程")]),v._v(" "),a("h3",{attrs:{id:"线程返回值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程返回值"}},[v._v("#")]),v._v(" 线程返回值")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("Callable")]),v._v(" + "),a("code",[v._v("FutureTask")]),v._v("，通过线程执行")]),v._v(" "),a("li",[v._v("创建线程池，通过 "),a("code",[v._v("submit")]),v._v(" 提交任务")])]),v._v(" "),a("h3",{attrs:{id:"线程状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程状态"}},[v._v("#")]),v._v(" 线程状态")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("NEW")]),v._v("：创建后尚未启动的线程状态")]),v._v(" "),a("li",[a("code",[v._v("Runnable")]),v._v("：运行状态，包含 "),a("code",[v._v("Running")]),v._v(" 和 "),a("code",[v._v("Ready")])]),v._v(" "),a("li",[a("code",[v._v("Waiting")]),v._v("：无限期等待，不会被分配 "),a("code",[v._v("CPU")]),v._v(" 执行时间，需要显式地被唤醒")]),v._v(" "),a("li",[a("code",[v._v("Timed Waiting")]),v._v("：有限期等待，需要被显式地唤醒或在一定时间后由系统自动唤醒")]),v._v(" "),a("li",[a("code",[v._v("Blocked")]),v._v("：阻塞状态，等待获取排它锁")]),v._v(" "),a("li",[a("code",[v._v("Terminated")]),v._v("：线程终止执行")])]),v._v(" "),a("h3",{attrs:{id:"sleep-和-wait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sleep-和-wait"}},[v._v("#")]),v._v(" sleep 和 wait")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("sleep()")]),v._v(" 是 "),a("code",[v._v("Thread")]),v._v(" 类的方法，"),a("code",[v._v("wait()")]),v._v(" 是 "),a("code",[v._v("Object")]),v._v(" 类的方法")]),v._v(" "),a("li",[a("code",[v._v("sleep()")]),v._v(" 可以在任何地方使用，"),a("code",[v._v("wait()")]),v._v(" 方法只能在 "),a("code",[v._v("synchronized")]),v._v(" 语句块内使用")]),v._v(" "),a("li",[a("code",[v._v("sleep()")]),v._v(" 只会让出 "),a("code",[v._v("CPU")]),v._v("，不会导致锁行为的改变，"),a("code",[v._v("wait()")]),v._v(" 方法不仅会让出 "),a("code",[v._v("CPU")]),v._v(" 资源，还会释放持有的锁资源")])]),v._v(" "),a("h3",{attrs:{id:"notify-和-notifyall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notify-和-notifyall"}},[v._v("#")]),v._v(" notify 和 notifyAll")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("锁池：对象的锁已被某个线程持有，则其它想要获得这个对象的锁的线程就会进入锁池等待锁的释放")])]),v._v(" "),a("li",[a("p",[v._v("等待池：某个线程调用了对象的 "),a("code",[v._v("wait()")]),v._v(" 方法，则会释放这个线程的锁，并进入该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁。")])]),v._v(" "),a("li",[a("p",[v._v("调用 "),a("code",[v._v("notify()")]),v._v(" 方法会从等待池中随机选取一个等待池中的线程进入锁池去竞争锁")])]),v._v(" "),a("li",[a("p",[v._v("调用 "),a("code",[v._v("notifyAll()")]),v._v(" 方法会让等待池中所有的线程进入锁池去竞争锁")])])]),v._v(" "),a("h3",{attrs:{id:"yield"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#yield"}},[v._v("#")]),v._v(" yield")]),v._v(" "),a("p",[v._v("调用 "),a("code",[v._v("yield()")]),v._v(" 表示当前线程愿意让出 "),a("code",[v._v("CPU")])]),v._v(" "),a("h3",{attrs:{id:"interrupt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interrupt"}},[v._v("#")]),v._v(" interrupt")]),v._v(" "),a("p",[v._v("通过调用 "),a("code",[v._v("interrupt()")]),v._v(" 方法可以通知线程应当中断：")]),v._v(" "),a("ul",[a("li",[v._v("如果线程处于阻塞状态，那么线程会立即退出阻塞状态并抛出 "),a("code",[v._v("InterruptedException")]),v._v("，如果捕捉了此异常，线程中断标志会被清除")]),v._v(" "),a("li",[v._v("如果线程处于正常活动的状态，线程会被打上中断标志，并继续正常运行")]),v._v(" "),a("li",[v._v("如果需要根据中断退出线程，则需要显式指定当线程中断标志为 "),a("code",[v._v("true")]),v._v("  时退出线程")])]),v._v(" "),a("h2",{attrs:{id:"synchronized"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[v._v("#")]),v._v(" Synchronized")]),v._v(" "),a("h3",{attrs:{id:"互斥锁的特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁的特性"}},[v._v("#")]),v._v(" 互斥锁的特性")]),v._v(" "),a("ul",[a("li",[v._v("互斥性：即在同一时刻只允许一个线程持有某个对象锁，这样在同一时刻只有一个线程对需要同步的代码块进行访问。互斥性也成为操作的原子性。")]),v._v(" "),a("li",[v._v("可见性：必须确保在锁释放之前，当前线程对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的。")])]),v._v(" "),a("h3",{attrs:{id:"自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[v._v("#")]),v._v(" 自旋锁")]),v._v(" "),a("p",[v._v("在许多情况下，共享数据的锁定状态持续时间较短，切换线程是不值得的，因此可以通过执行忙循环的方式不让出 "),a("code",[v._v("CPU")]),v._v("，但是如果忙循环长时间执行，则可能会带来更多性能上的开销。")]),v._v(" "),a("h3",{attrs:{id:"锁消除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[v._v("#")]),v._v(" 锁消除")]),v._v(" "),a("p",[a("code",[v._v("JIT")]),v._v(" 编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。")]),v._v(" "),a("h3",{attrs:{id:"锁粗化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁粗化"}},[v._v("#")]),v._v(" 锁粗化")]),v._v(" "),a("p",[v._v("一系列操作对同一个对象反复加锁，通过扩大锁的范围对锁粗话，避免反复加锁增加的开销。")]),v._v(" "),a("h3",{attrs:{id:"偏向锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[v._v("#")]),v._v(" 偏向锁")]),v._v(" "),a("p",[v._v("如果某个线程获取了锁，到再次请求锁时，没有其他线程再去请求该锁，则省略线程申请锁的同步操作。")]),v._v(" "),a("h3",{attrs:{id:"轻量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[v._v("#")]),v._v(" 轻量级锁")]),v._v(" "),a("p",[v._v("线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 "),a("code",[v._v("Mark Word")]),v._v(" 复制到锁记录中，然后线程尝试使用 "),a("code",[v._v("CAS")]),v._v(" 将对象头中的 "),a("code",[v._v("Mark Word")]),v._v(" 替换为指向锁记录的指针。如果成功则线程可以顺利进入临界区，如果失败，锁请求会膨胀为重量级锁")]),v._v(" "),a("p",[a("img",{attrs:{src:"/img/interview/%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png",alt:"锁优缺点和使用场景"}})]),v._v(" "),a("h2",{attrs:{id:"reentrantlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[v._v("#")]),v._v(" ReentrantLock")]),v._v(" "),a("h2",{attrs:{id:"java-内存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-内存模型"}},[v._v("#")]),v._v(" Java 内存模型")]),v._v(" "),a("h3",{attrs:{id:"工作内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作内存"}},[v._v("#")]),v._v(" 工作内存")]),v._v(" "),a("ul",[a("li",[v._v("存储当前方法的所有本地变量信息，本地变量对其它线程不可见。")]),v._v(" "),a("li",[v._v("字节码行号指示器、"),a("code",[v._v("native")]),v._v(" 方法信息")]),v._v(" "),a("li",[v._v("线程私有，不会造成线程安全问题")])])])}),[],!1,null,null,null);_.default=e.exports}}]);