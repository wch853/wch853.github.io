(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{219:function(e,_,v){"use strict";v.r(_);var t=v(0),s=Object(t.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"elasticsearch（三）：集群特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch（三）：集群特性"}},[e._v("#")]),e._v(" Elasticsearch（三）：集群特性")]),e._v(" "),v("h2",{attrs:{id:"cluster-state"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cluster-state"}},[e._v("#")]),e._v(" cluster state")]),e._v(" "),v("p",[v("code",[e._v("es")]),e._v(" 集群相关的数据称为 "),v("code",[e._v("cluster state")]),e._v("，主要记录：")]),e._v(" "),v("ul",[v("li",[e._v("节点信息，如节点名称、连接地址等。")]),e._v(" "),v("li",[e._v("索引信息，如索引名称、配置等。")])]),e._v(" "),v("p",[e._v("能够修改 "),v("code",[e._v("cluster state")]),e._v(" 的节点称为 "),v("code",[e._v("master")]),e._v(" 节点，"),v("code",[e._v("master")]),e._v(" 节点维护 "),v("code",[e._v("cluster state")]),e._v(" 并将最新版本的数据同步给其它结点。"),v("code",[e._v("master")]),e._v(" 节点是通过选举产生的，可以被选举的节点称为 "),v("code",[e._v("master-eligible")]),e._v(" 节点。")]),e._v(" "),v("h2",{attrs:{id:"coordinating-node"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#coordinating-node"}},[e._v("#")]),e._v(" coordinating node")]),e._v(" "),v("p",[e._v("处理请求的节点即为 "),v("code",[e._v("coordinating node")]),e._v("，是所有节点的默认角色，不可取消。"),v("code",[e._v("coordinating node")]),e._v(" 负责路由请求到正确的节点处理。")]),e._v(" "),v("h2",{attrs:{id:"data-node"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#data-node"}},[e._v("#")]),e._v(" data node")]),e._v(" "),v("p",[e._v("存储数据的节点即为 "),v("code",[e._v("data node")]),e._v("，默认节点均为 "),v("code",[e._v("data node")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"副本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#副本"}},[e._v("#")]),e._v(" 副本")]),e._v(" "),v("p",[v("code",[e._v("es")]),e._v(" 引入副本（"),v("code",[e._v("replica")]),e._v("）提高了服务可用性和数据可用性，创建索引时使用 "),v("code",[e._v("number_of_replicas")]),e._v(" 参数指定副本数。")]),e._v(" "),v("ul",[v("li",[e._v("应对部分节点停止服务问题。")]),e._v(" "),v("li",[e._v("在不同节点上进行数据备份。")])]),e._v(" "),v("h2",{attrs:{id:"分片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分片"}},[e._v("#")]),e._v(" 分片")]),e._v(" "),v("ul",[v("li",[e._v("通过分片（"),v("code",[e._v("shard")]),e._v("）使得数据可以进行拆分，分布在任意节点上。创建索引时使用 "),v("code",[e._v("number_of_shards")]),e._v(" 参数指定分片数。")]),e._v(" "),v("li",[e._v("分片是 "),v("code",[e._v("es")]),e._v(" 支持 "),v("code",[e._v("PB")]),e._v(" 级数据的基石。")]),e._v(" "),v("li",[e._v("分片数在索引创建时指定并且后续不允许修改。")]),e._v(" "),v("li",[e._v("分片有主分片和副本分片之分，副本分片的数据由主分片同步。副本分片可以有多个，用以提高吞吐量。")])]),e._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token constant"}},[e._v("PUT")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("test\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v('"settings"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v('"number_of_shards"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" \n    "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v('"number_of_replicas"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),v("h2",{attrs:{id:"cluster-health"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cluster-health"}},[e._v("#")]),e._v(" cluster health")]),e._v(" "),v("p",[e._v("通过 "),v("code",[e._v("GET /_cluster/health")]),e._v(" 可以查看 "),v("code",[e._v("es")]),e._v(" 集群状态，包括以下三种：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("green")]),e._v("：健康状态，所有主副分片都正常分配。")]),e._v(" "),v("li",[v("code",[e._v("yello")]),e._v("：所有主分片都分配正常，但有副本分片未正常分配。")]),e._v(" "),v("li",[v("code",[e._v("red")]),e._v("：有主分片未分配完成。")])]),e._v(" "),v("h2",{attrs:{id:"故障转移"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#故障转移"}},[e._v("#")]),e._v(" 故障转移")]),e._v(" "),v("p",[e._v("非 "),v("code",[e._v("master")]),e._v(" 节点会不停查看 "),v("code",[e._v("mater")]),e._v(" 节点的状态，如果发现 "),v("code",[e._v("master")]),e._v(" 节点无法提供服务，会重新选举 "),v("code",[e._v("master")]),e._v(" 节点，选举规则为当前集群可选举结点数大于 "),v("code",[e._v("quorom")]),e._v(" 时才可以选举，"),v("code",[e._v("quorom = 所有可选举结点数 / 2 + 1")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"分布式存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式存储"}},[e._v("#")]),e._v(" 分布式存储")]),e._v(" "),v("p",[v("code",[e._v("coordinating node")]),e._v(" 收到请求后会通过文档映射算法用文档 "),v("code",[e._v("id")]),e._v(" 计算文档所在的分片，如果是查询请求会获取该分片的主副分片列表，然后以轮询的机制到某个分片上执行查询，然后将结果返回给 "),v("code",[e._v("coordinating node")]),e._v("；如果是写入请求，在计算文档的分片后会将写入请求转发给主分片，主分片成功执行后会将请求转发给副本分片，主分片收到副本分片返回结果后通知 "),v("code",[e._v("coordinating node")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"倒排索引不可变特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#倒排索引不可变特性"}},[e._v("#")]),e._v(" 倒排索引不可变特性")]),e._v(" "),v("p",[e._v("倒排索引一旦生成，不能修改，好处如下：")]),e._v(" "),v("ul",[v("li",[e._v("不用考虑并发写文件的问题，杜绝了锁机制带来的性能问题。")]),e._v(" "),v("li",[e._v("由于文件不再更改，可以充分利用文件系统缓存，只需载入一次，在内存足够的情况下对该文件的读取都会从内存读取，性能更高。")]),e._v(" "),v("li",[e._v("利于生成缓存数据。")]),e._v(" "),v("li",[e._v("利于对文件进行压缩存储，节省磁盘和内存存储空间。")])]),e._v(" "),v("h2",{attrs:{id:"倒排索引维护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#倒排索引维护"}},[e._v("#")]),e._v(" 倒排索引维护")]),e._v(" "),v("p",[v("code",[e._v("lucene")]),e._v(" 针对倒排索引不可变问题的解决方案是生成新的倒排索引文件，查询时同时查询所有的倒排索引文件，然后汇总结果。这样构建的单个倒排索引称为 "),v("code",[e._v("segment")]),e._v("，专门记录 "),v("code",[e._v("segment")]),e._v(" 信息的文件称为 "),v("code",[e._v("commit point")]),e._v("，"),v("code",[e._v("segment")]),e._v(" 和 "),v("code",[e._v("commit point")]),e._v(" 构成了 "),v("code",[e._v("lucene index")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"refresh"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#refresh"}},[e._v("#")]),e._v(" refresh")]),e._v(" "),v("p",[v("code",[e._v("segement")]),e._v(" 写入磁盘的过程耗时较长，可以借助文件系统的缓存特性，先将 "),v("code",[e._v("segement")]),e._v(" 在缓存中创建并开放查询来进一步提升实时性。该过程在 "),v("code",[e._v("es")]),e._v(" 中称为 "),v("code",[e._v("refresh")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"index-buffer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#index-buffer"}},[e._v("#")]),e._v(" index buffer")]),e._v(" "),v("p",[e._v("在 "),v("code",[e._v("refresh")]),e._v(" 之前文档会先存储在一个内存 "),v("code",[e._v("buffer")]),e._v(" 中，"),v("code",[e._v("refresh")]),e._v(" 时将 "),v("code",[e._v("buffer")]),e._v(" 中的所有文档清空并在内存中生成 "),v("code",[e._v("segment")]),e._v("。由于 "),v("code",[e._v("index buffer")]),e._v(" 的存在，"),v("code",[e._v("refresh")]),e._v(" 可以等待一段时间来生成 "),v("code",[e._v("segement")]),e._v("，"),v("code",[e._v("es")]),e._v(" 默认每 "),v("code",[e._v("1")]),e._v(" 秒执行一次 "),v("code",[e._v("refresh")]),e._v("，这就是 "),v("code",[e._v("近实时")]),e._v(" 的由来。")]),e._v(" "),v("h3",{attrs:{id:"translog"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#translog"}},[e._v("#")]),e._v(" translog")]),e._v(" "),v("p",[v("code",[e._v("translog")]),e._v(" 机制是为了应对内存中的 "),v("code",[e._v("index buffer")]),e._v(" 或 "),v("code",[e._v("segement")]),e._v(" 还未写进磁盘时发生宕机等事故导致数据丢失的问题。")]),e._v(" "),v("ul",[v("li",[e._v("当变更写入 "),v("code",[e._v("buffer")]),e._v(" 时 "),v("code",[e._v("es")]),e._v(" 会将操作同步写入 "),v("code",[e._v("translog")]),e._v("，"),v("code",[e._v("translog")]),e._v(" 文件会即时写入磁盘（通过 "),v("code",[e._v("fsync")]),e._v("）。")]),e._v(" "),v("li",[v("code",[e._v("es")]),e._v(" 启动时会检查 "),v("code",[e._v("translog")]),e._v(" 文件，并从中恢复数据。")])]),e._v(" "),v("h3",{attrs:{id:"flush"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flush"}},[e._v("#")]),e._v(" flush")]),e._v(" "),v("p",[v("code",[e._v("flush")]),e._v(" 负责将内存中的 "),v("code",[e._v("segment")]),e._v(" 写入磁盘：")]),e._v(" "),v("ul",[v("li",[e._v("将 "),v("code",[e._v("translog")]),e._v(" 写入磁盘。")]),e._v(" "),v("li",[e._v("将 "),v("code",[e._v("index buffer")]),e._v(" 清空，其中的文档生成一个新的 "),v("code",[e._v("segement")]),e._v("，相当于 "),v("code",[e._v("refresh")]),e._v(" 操作。")]),e._v(" "),v("li",[e._v("执行 "),v("code",[e._v("fsync")]),e._v("，将内存中的 "),v("code",[e._v("segement")]),e._v(" 写入磁盘。")]),e._v(" "),v("li",[e._v("更新 "),v("code",[e._v("commit point")]),e._v(" 文件，记录新增的 "),v("code",[e._v("segment")]),e._v("。")]),e._v(" "),v("li",[e._v("删除旧的 "),v("code",[e._v("translog")]),e._v(" 文件。")])]),e._v(" "),v("p",[v("code",[e._v("flush")]),e._v(" 默认间隔时间是 "),v("code",[e._v("30")]),e._v(" 分钟，当 "),v("code",[e._v("translog")]),e._v(" 超过一定大小时也会触发 "),v("code",[e._v("flush")]),e._v("。")]),e._v(" "),v("h3",{attrs:{id:"删除文档"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除文档"}},[e._v("#")]),e._v(" 删除文档")]),e._v(" "),v("p",[v("code",[e._v("lucene")]),e._v(" 专门维护了一个 "),v("code",[e._v(".del")]),e._v(" 文件，记录已删除的文档（文档在 "),v("code",[e._v("lucene")]),e._v(" 内部的 "),v("code",[e._v("id")]),e._v("），查询时会通过 "),v("code",[e._v(".del")]),e._v(" 文件进行过滤。更新文档也是通过先删除文档再创建新的文档来实现的。")]),e._v(" "),v("h3",{attrs:{id:"segment-merging"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#segment-merging"}},[e._v("#")]),e._v(" segment merging")]),e._v(" "),v("p",[e._v("随着 "),v("code",[e._v("segment")]),e._v(" 的增多，"),v("code",[e._v("es")]),e._v(" 会定期在后台执行合并操作来减少 "),v("code",[e._v("segment")]),e._v(" 的数量。通过 "),v("code",[e._v("force_merge")]),e._v(" 可以手动强制做 "),v("code",[e._v("segement merge")]),e._v(" 操作。")])])}),[],!1,null,null,null);_.default=s.exports}}]);