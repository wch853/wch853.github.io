(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{261:function(v,_,a){"use strict";a.r(_);var t=a(0),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"深入理解计算机系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入理解计算机系统"}},[v._v("#")]),v._v(" 深入理解计算机系统")]),v._v(" "),a("h2",{attrs:{id:"系统硬件组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统硬件组成"}},[v._v("#")]),v._v(" 系统硬件组成")]),v._v(" "),a("h3",{attrs:{id:"总线"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总线"}},[v._v("#")]),v._v(" 总线")]),v._v(" "),a("p",[v._v("贯穿整个系统的是一组电子管道，称作 "),a("code",[v._v("总线")]),v._v("，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字，字中的字节数（字长）是一个基本的系统参数，现在大多数机器通常是4个字节（32位）或8个字节（64位）。")]),v._v(" "),a("h3",{attrs:{id:"i-o-设备"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i-o-设备"}},[v._v("#")]),v._v(" I/O 设备")]),v._v(" "),a("p",[a("code",[v._v("I/O")]),v._v("（输入/输出）设备是系统与外部世界的联系通道。每个 "),a("code",[v._v("I/O")]),v._v(" 设备都通过一个控制器或适配器与 "),a("code",[v._v("I/O")]),v._v(" 总线相连，它们的功能是传递信息。")]),v._v(" "),a("h3",{attrs:{id:"主存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主存"}},[v._v("#")]),v._v(" 主存")]),v._v(" "),a("p",[v._v("主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（"),a("code",[v._v("DRAM")]),v._v("）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从0开始的。")]),v._v(" "),a("h3",{attrs:{id:"处理器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理器"}},[v._v("#")]),v._v(" 处理器")]),v._v(" "),a("p",[v._v("中央处理单元（"),a("code",[v._v("CPU")]),v._v("），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（"),a("code",[v._v("PC")]),v._v("）。在任何时刻，"),a("code",[v._v("PC")]),v._v(" 都指向主存中的某条机器语言指令（即含有该条指令的地址）。")]),v._v(" "),a("p",[a("code",[v._v("CPU")]),v._v(" 在指令的要求下可能会执行这些操作：")]),v._v(" "),a("ul",[a("li",[v._v("加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。")]),v._v(" "),a("li",[v._v("存储：从寄存器复制一个字节或一个字到主存的某个位置，以覆盖这个位置上原来的内容。")]),v._v(" "),a("li",[v._v("操作：把两个寄存器的内容复制到 "),a("code",[v._v("ALU")]),v._v("（算数/逻辑单元），对复制内容做算数运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。")]),v._v(" "),a("li",[v._v("跳转：从指令本身中抽取一个字，将这个字复制到程序计数器中，以覆盖程序计数器中原来的值。")])]),v._v(" "),a("p",[a("img",{attrs:{src:"D:%5CJava%5Ccode%5CVisualStudioCodeProjects%5Cwch853.github.io/img/csapp/%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png",alt:"一个典型系统的硬件组成"}})]),v._v(" "),a("h2",{attrs:{id:"高速缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高速缓存"}},[v._v("#")]),v._v(" 高速缓存")]),v._v(" "),a("p",[v._v("程序的机器指令最初是放在磁盘上，当程序加载时，它们被复制到主存中，当处理器开始运行程序，指令又从主存复制到处理器。对于程序的整个运行流程来说，复制就是开销，系统设计的一个主要目标就是使得这些复制操作尽可能快地完成。")]),v._v(" "),a("p",[v._v("根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。例如一个典型系统上的磁盘驱动器可能比主存大1000倍，但是从磁盘驱动器上读取一个字的时间开销要比从主存中读取大1000万倍；类似的，一个典型的寄存器文件只存储几百字节的信息，而主存中可能存储几十亿字节，然而处理器从寄存器中读数据比从主存中读取几乎要快100倍。针对处理器与主存间的差异，系统设计者使用 "),a("code",[v._v("高速缓存存储器")]),v._v(" 作为暂时的数据集结区域，存放处理器近期可能会需要的信息。")]),v._v(" "),a("p",[a("img",{attrs:{src:"D:%5CJava%5Ccode%5CVisualStudioCodeProjects%5Cwch853.github.io/img/csapp/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1.png",alt:"高速缓存设计"}})]),v._v(" "),a("p",[v._v("位于处理器上的 "),a("code",[v._v("L1高速缓存")]),v._v(" 的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的 "),a("code",[v._v("L2高速缓存")]),v._v(" 通过一条特殊的总线连接到处理器，"),a("code",[v._v("L2高速缓存")]),v._v(" 相对于 "),a("code",[v._v("L1高速缓存")]),v._v(" 慢，但是仍比访问主存快 5 ~ 10 倍，有些系统甚至有更多类型的高速缓存。")]),v._v(" "),a("p",[v._v("系统通过高速缓存获取了一个很大的存储器，同时访问速度也很快。原因是利用了 "),a("code",[v._v("局部性原理")]),v._v("，即程序具有访问局部区域里的数据和代码的趋势。通过在高速缓存里存放可能经常访问的数据，大部分的内存操作都能在高速缓存中完成。")]),v._v(" "),a("h2",{attrs:{id:"存储器层次结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储器层次结构"}},[v._v("#")]),v._v(" 存储器层次结构")]),v._v(" "),a("p",[a("img",{attrs:{src:"D:%5CJava%5Ccode%5CVisualStudioCodeProjects%5Cwch853.github.io/img/csapp%5C%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png",alt:"存储器层次结构"}})]),v._v(" "),a("h2",{attrs:{id:"操作系统管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统管理"}},[v._v("#")]),v._v(" 操作系统管理")]),v._v(" "),a("h3",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[v._v("#")]),v._v(" 进程")]),v._v(" "),a("p",[a("code",[v._v("进程")]),v._v(" 是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交替执行的。操作系统实现这种交替执行的机制称为 "),a("code",[v._v("上下文切换")]),v._v("。")]),v._v(" "),a("p",[v._v("操作系统保持跟踪进程进行所需的所有状态信息，这种状态，也就是上下文，包含许多信息，比如程序计数器和寄存器文件的当前值，以及主存的内容。单个处理器在任何时候都只能执行一个进程的代码，当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行 "),a("code",[v._v("上下文切换")]),v._v("，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程，新进程就会从它上次停止的地方开始。")]),v._v(" "),a("h3",{attrs:{id:"线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[v._v("#")]),v._v(" 线程")]),v._v(" "),a("p",[v._v("在现代系统中，一个进程可由多个称为线程的执行单元组成。每个线程都在进程的上下文中，并共享同样的代码和全局数据。由于线程间比进程间更容易共享数据、线程一般也比进程更高效、在多处理器的情况下，多线程可以使程序运行得更快，线程成为越来越重要的编程模型。")]),v._v(" "),a("h3",{attrs:{id:"虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[v._v("#")]),v._v(" 虚拟内存")]),v._v(" "),a("p",[v._v("虚拟内存是一个抽象概念，它为每个进程提供了好像在独占使用主存的假象。每个进程看到的内存都是一致的，称为虚拟地址空间。")]),v._v(" "),a("h3",{attrs:{id:"文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件"}},[v._v("#")]),v._v(" 文件")]),v._v(" "),a("p",[v._v("文件就是字节序列，它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 "),a("code",[v._v("I/O")]),v._v(" 设备。")]),v._v(" "),a("h2",{attrs:{id:"网络通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络通信"}},[v._v("#")]),v._v(" 网络通信")]),v._v(" "),a("p",[v._v("从一个单独的网络系统来看，网络可视为一个 "),a("code",[v._v("I/O")]),v._v(" 设备。当系统从主存复制一串字节到网络适配器时，数据流经网络到达另一台机器，类似地，系统可以读取其它机器发来的数据，并把数据复制到自己的主存。")]),v._v(" "),a("h2",{attrs:{id:"信息存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信息存储"}},[v._v("#")]),v._v(" 信息存储")]),v._v(" "),a("p",[v._v("大多数计算机使用8位的块，或者字节作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为 "),a("code",[v._v("虚拟内存")]),v._v("。内存的每个字节都由一个唯一的数字来标识，称为它的 "),a("code",[v._v("地址")]),v._v("。所有可能的地址的集合就称为 "),a("code",[v._v("虚拟地址空间")]),v._v("，实际实现是将动态随机访问存储器（"),a("code",[v._v("DRAM")]),v._v("）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。")]),v._v(" "),a("h3",{attrs:{id:"十六进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十六进制"}},[v._v("#")]),v._v(" 十六进制")]),v._v(" "),a("p",[v._v("以 "),a("code",[v._v("0x")]),v._v(" 或 "),a("code",[v._v("0X")]),v._v(" 开头的数字常量被认为是十六进制的值。十六进制使用数字 "),a("code",[v._v("0 ~ 9")]),v._v(" 以及字符 "),a("code",[v._v("a ~ f")]),v._v(" 来表示16个可能的值。")]),v._v(" "),a("h3",{attrs:{id:"字数据大小"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字数据大小"}},[v._v("#")]),v._v(" 字数据大小")]),v._v(" "),a("p",[v._v("每台计算机都有一个 "),a("code",[v._v("字长")]),v._v("，指明指针数据的标称大小。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数是虚拟地址空间的最大大小。因此对于字长为 "),a("code",[v._v("w")]),v._v(" 的机器而言，虚拟地址的范围为 "),a("code",[v._v("0 ~ 2^w - 1")]),v._v("，即程序最多访问 "),a("code",[v._v("2^w")]),v._v(" 个字节。从 "),a("code",[v._v("32位")]),v._v(" 字长机器迁移到 "),a("code",[v._v("64位")]),v._v(" 字长机器使得虚拟地址空间大规模扩大（突破 "),a("code",[v._v("32位")]),v._v(" 的 "),a("code",[v._v("4GB")]),v._v(" 地址限制）。")]),v._v(" "),a("h3",{attrs:{id:"寻址和字节顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寻址和字节顺序"}},[v._v("#")]),v._v(" 寻址和字节顺序")]),v._v(" "),a("p",[v._v("在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中的最小地址。排列对象字节的顺序有两个通用规则，即低位在前的 "),a("code",[v._v("小端法")]),v._v(" 和 高位在前的 "),a("code",[v._v("大端法")]),v._v("。")])])}),[],!1,null,null,null);_.default=e.exports}}]);